// This script is used in transfer curves taken with the low noise rig in two drain voltages. It loops over all the workbooks in the folder and plots the transfer and output curves.
// It then calculates and plots the (linear and saturation) mobility, transconductance, threshold voltage, and reliability factor.
// NOTE: The saturation curve is best measured by short-circuiting the drain and gate and sweeping them simultaneously. This eliminates any chance of minority carriers participating in the mobility calculations.

// How to use:
// 1. Set the capacitance per area value from impedance analysis measurements (or the thickness of the dielectric from profilometry).
// 2. Run the script.
// 3. Check that the Vt linear fitting is correct. Otherwise adjust the slope window (difference between current fit slope and fit slope for Vgmax). Increase the window to relax the constraints for "flatness" of SQRT(Id). Then re-run the script.
// 4. If the Id(Vdlin) pleateaus near Vgmax, then increase the offset value, in order to exclude some of the high Vg values from the linear fit. This plateau normally happens in the linear regime.

// Author: Dimitrios Simatos
// Version: 7.3
// Current status: Automatic offset calculation does not always work.
// Changes: Code tidy up and automatic offset code correction.


// Thickness
// CYTOP-M 100% (Caironi's recipe): The measured thickness is 310 nm. The thickness mentioned in the paper is 450 nm.
// CYTOP-S 100%: The measured thickness is 570 nm.
// CYTOP-M 3-1: 550 nm
// CYTOP-M 1-5: 25 nm
// CYTOP-S 3-1: 860 nm
// CYTOP-S 1.5-1: 490 nm
// CYTOP-S 1-1: 370 nm
// CYTOP-S 1-2: 140 nm
// CYTOP-S 1-3: 100 nm
// PMMA: 300 nm

[Main]
//uncomment following line to define functions using outside of this scope
//@global=1;

//-----------------------------------------------------------------------------------------------------------------------------------------------------------

	del -al *;// Delete all the local and session variables
	
//-----------------------------------------------------------------------------------------------------------------------------------------------------------
function string findConcunits (string concunits)
{
	switch (%(concunits$)) // Case study
		{
			case "gl": // If the string is "gl", write "g/l" in the comment field
				conunitslegend$ = "g/l"; // Comment field (graph legend)
				break;
			
			default: // For all other numbers, use plural form
				conunitslegend$ = "mg/ml"; // Comment field (graph legend)
				break;
		}
			
		return conunitslegend$;
}

function string findAdditive (string additivetype)
{
	switch (%(additivetype$)) // Case study
		{
			case "Pristine": // If the string is "TCNQ", write "TCNQ" in the comment field
				additivegraphlegend$ = "Pristine"; // Comment field (graph legend)
				break;
			
			case "TCNQ": // If the string is "TCNQ", write "TCNQ" in the comment field
				additivegraphlegend$ = "+ TCNQ"; // Comment field (graph legend)
				break;
			
			case "F2TCNQ": // If the string is "F2TCNQ", write "F2TCNQ" in the comment field
				additivegraphlegend$ = "+ F2TCNQ"; // Comment field (graph legend)
				break;
			
			case "F4TCNQ": // If the string is "F4TCNQ", write "F4TCNQ" in the comment field
				additivegraphlegend$ = "+ F4TCNQ"; // Comment field (graph legend)
				break;
			
			case "SAM-1OCT-v": // If the number is 1, use single form
				additivegraphlegend$ = "+ 1-Octanethiol (vapor)"; // Comment field (graph legend)
				break;
			
			case "SAM-1OCT-i": // If the number is 1, use single form
				additivegraphlegend$ = "+ 1-Octanethiol (immersion)"; // Comment field (graph legend)
				break;
			
			case "SAM-TDF1OCT-v": // If the number is 1, use single form
				additivegraphlegend$ = "+ 3,3,4,4,5,5,6,6,7,7,8,8,8-Tridecafluoro-1-octanethiol (vapor)"; // Comment field (graph legend)
				break;
			
			case "SAM-TDF1OCT-i": // If the number is 1, use single form
				additivegraphlegend$ = "+ 3,3,4,4,5,5,6,6,7,7,8,8,8-Tridecafluoro-1-octanethiol (immersion)"; // Comment field (graph legend)
				break;
			
			default: // For all other strings, write "Pristine" in the comment field
				additivegraphlegend$ = "Pristine"; // Comment field (graph legend)
				break;
		}
			
		return additivegraphlegend$;
}

function string findCondition (string condition)
{
	switch (%(condition$)) // Case study
		{
			case "DI-H2O": // If the string is "ultrapure", write "ultrapure water" in the comment field
				condgraphlegend$ = "DI water"; // Comment field (graph legend)
				break;
			
			case "up-H2O": // If the string is "ultrapure", write "ultrapure water" in the comment field
				condgraphlegend$ = "Ultrapure water"; // Comment field (graph legend)
				break;
			
			case "t-H2O": // If the string is "town", write "town water" in the comment field
				condgraphlegend$ = "Town water"; // Comment field (graph legend)
				break;
			
			case "ss": // If the string is "town", write "town water" in the comment field
				condgraphlegend$ = "Saline solution"; // Comment field (graph legend)
				break;
			
			case "pbuffer": // If the string is "phosphatebuffer", write "Phosphate buffer (pH="pHValue", "buffer concentration" "buffer concentration units")" in the comment field
				string pH$ = condition.GetToken(2,"-")$; // get the string, which shows the pH
				pH$ = pH.Substitute(".", ",", 0)$; // Substitute comma with dot
				string bufferconcentration$ = condition.GetToken(3,"-")$; // get the string, which shows the buffer concentration
				string bufferconcunits$ = condition.GetToken(4,"-")$; // get the string, which shows the buffer concentration
				condgraphlegend$ = "Phosphate buffer (pH= %(pH$), %(bufferconcentration$) %(bufferconcunits$)"; // Comment field (graph legend)
				break;
				
			default: // For all other strings, write the condition string in the comment field
				condgraphlegend$ = condition$; // Comment field (graph legend)
				break;
		}
			
		return condgraphlegend$;
}

function string findTime (string timelength)
{
	if (timelength$ != "initial")
		{
			timeNo$ = timelength.GetToken(1,"-")$; // get the string, which shows the time (number)
			timeunits$ = timelength.GetToken(2,"-")$; // get the string, which shows the time units
			
			if (timeunits$ == "min")
				timeunits$ = "minutes";
			
			timegraphlegend$ = timeNo$ + " " + timeunits$; // Comment field (graph legend)
			
			if (timeNo$ == "1")
				timegraphlegend.TrimRight("s"); // If the number is 1, use single form
			
		};
		else
			//timegraphlegend$ = timelength$; // Legend
			timegraphlegend$ = "Initial"; // Legend
			
		return timegraphlegend$;
}

function string findMode (string mode)
{
	switch (%(mode$)) // Case study
		{
			case "P": // If the string is "P", write "Pulsed" in the comment field
				modegraphlegend$ = "Pulsed"; // Comment field (graph legend)
				break;
			
			case "C": // If the string is "C", write "Continuous" in the comment field
				modegraphlegend$ = "Continuous"; // Comment field (graph legend)
				break;
			
			default: // For all other cases, write "Continuous" in the comment field
				modegraphlegend$ = "Continuous"; // Comment field (graph legend)
				break;
		}
			
		return modegraphlegend$;
}

function string findInTime (string intime)
{
	switch (%(intime$)) // Case study
		{
			case "S": // If the string is "S", write "Short" in the comment field
				intimegraphlegend$ = "Short"; // Comment field (graph legend)
				break;
			
			case "M": // If the string is "M", write "Medium" in the comment field
				intimegraphlegend$ = "Medium"; // Comment field (graph legend)
				break;
			
			case "L": // If the string is "L", write "Long" in the comment field
				intimegraphlegend$ = "Long"; // Comment field (graph legend)
				break;
			
			default: // For all other cases, write "Long" in the comment field
				intimegraphlegend$ = "Long"; // Comment field (graph legend)
				break;
		}
			
		return intimegraphlegend$;
}

// The linear fitting is done from Id(Vgmax)+offset to the i. Id(Vgmax)+offset is the left limit of the voltage range for the linear fit.
// The index i shows the right limit of the voltage range for the linear fit. It starts from maxrows/2 (Id(Vgmax)) + minRangeLength (the min voltage range I want to fit on; if this is zero, then the left and right limits will overlap) + offset (correction factor in case Id plateaus at the left limit of the range (Vgmax). This happens in the linear regime.).
// The loop extends from the minimum i value to the end of the voltage range (maxrows). Moving i to the right (via the loop) constitutes the rolling window.

function double RollingRegression (range inputcols, range outputcol, int minRangeLength, double slopewindow, int offsetwindow)
{
	double Vt; // Threshold voltage (Temporary variable to be used in the Rolling Regression function)
	double firstfit; // The first value of the slope of the linear fit (done between Id(Vgmax) and Id(Vg(i=0)).
	double prevfit = 100; // The previous value of the slope of the linear fit (done between Vg(Idmax) and Vg(Id(i))).
	int offset = 0; // Offset initialization. If the dId/dV function plateaus, I do not start the integration from Id(Vgmax), as the slope will be positive and the fitting curve will rise to infinity. So, now the left limit of the voltage range will start from Id(Vgmax+offset)
	int rowIdmax; // The row number of Idmax.
	
	// Calculate the offset
	fitLR iy:=inputcols[wks.maxrows/2:wks.maxrows/2 + minRangeLength]; // Linear fit from Id(Vgmax) to Id(Vgmax)+minRangeLength (offset=0).
	if (fitLR.b>0) // If the slope is positive, it will rise to infinity and not intercept the X-axis, resulting in a bad fit.
	{
		range rIdmax = inputcols[wks.maxrows/2:wks.maxrows];
		sum(rIdmax); // Generate statistics on input column
		rowIdmax = $(sum.imax); // The row number of Idmax.
		rowIdmax=;
		loop(i,0,wks.maxrows-minRangeLength) // The index i shifts both limits of the integration towards the lower voltages by the same amount, stopping when the slope of the linear fit stops changing. 
			{
				fitLR iy:=inputcols[i+rowIdmax:i+rowIdmax+minRangeLength]; // Linear fit from Vg(Idmax) to Vg(Id(i)). The loop shifts both ends of the voltage range over which the linear fit is applied.
				i=; // Uncomment these three lines if the slope window is out of bounds. Then look at the console and see where abs(firstfit - fitLR.b) varies. Then correct the window value, and comment the lines again.
				fitLR.b=;
				abs(prevfit - fitLR.b)/abs(fitLR.b)*100=;
				if (abs(prevfit - fitLR.b)/abs(fitLR.b)*100 < offsetwindow) // Window for extracting the rolling window slope. The window is normalized with respect to the first slope, and then mupltiplied by 100, to turn it into a percentage.
					{
						offset = i + rowIdmax - wks.maxrows/2;
						break;
					};
					else
					{
						prevfit = fitLR.b;
						continue;
					};
			};
	};
	offset=;
	loop(i,wks.maxrows/2 + minRangeLength + offset,wks.maxrows) // Start at least "minRangeLength" points after the Vgmax point. I want the linear fit to have a sufficient number of points, and not have the range be too small.
	{
		fitLR iy:=inputcols[wks.maxrows/2+offset:i] oy:=outputcol; // Linear fit from Id(Vgmax) to Id(Vg(i)). The loop moves the rightmost end of the voltage range over which the linear fit is applied.
		if (i == wks.maxrows/2 + minRangeLength + offset) // If i is equal to the initial value of the loop, then store the value in the "firstfit" variable. All fit differences will be calculated with this reference, and compared with the slope window.
			{
				firstfit = fitLR.b;
				//firstfit = ;
				continue;
			};
		//i=; // Uncomment these three lines if the slope window is out of bounds. Then look at the console and see where abs(firstfit - fitLR.b) varies. Then correct the window value, and comment the lines again.
		//fitLR.b=;
		//firstfit - fitLR.b=;
		//abs(firstfit - fitLR.b)/abs(firstfit)*100=;
		if ((abs(firstfit - fitLR.b)/abs(firstfit))*100 > slopewindow) // Window for extracting the rolling window slope. The window is normalized with respect to the first slope, and then mupltiplied by 100, to turn it into a percentage.
			{
				Vt = -fitLR.a/fitLR.b; // To find the threshold voltage, divide the intercept with the slope.
				Vt = round(Vt,1); // Round the threshold voltage
				break;
			};
		else
			continue;
	}
			
	return Vt;
}

function double PowerLawFit (range inputcols, range outputcol, int minRangeLength, double slopewindow)
{
	double beta; // Parameter for power law dependence of the mobility
	double firsterror; // The error value of the power law fit (done between Id(Vgmax) and Id(Vg(i=0)).
	int offset = 0; // Offset value in case the mobility function plateaus. The left limit of the voltage range will start from mu(Vgmax+offset) (Saturation)

	loop(i,wks.maxrows/2 + minRangeLength + offset,wks.maxrows) // Start at least "minRangeLength" points after the Vgmax point. I want the linear fit to have a sufficient number of points, and not have the range be too small.
	{
		nlbegin iy:=inputcols[wks.maxrows/2+offset:i] func:=Power1 nltree:=ParamTree weight:=0; // Fit from u(Vgmax) to u(Vg(i)). The loop moves the rightmost end of the voltage range over which the linear fit is applied.
		ParamTree.xc = 0;     // Assign the peak center an X-value of 0.
		ParamTree.f_xc = 1;   // Fix the peak center (f_xc = 0 is unfixed).		
		nlfit;
		if (i == wks.maxrows/2 + minRangeLength) // If i is equal to the initial value of the loop, then store the value in the "firstfit" variable. All fit differences will be calculated with this reference, and compared with the slope window.
			{
				firsterror = ParamTree.rmse;
				continue;
			};
		i=; // Uncomment these two lines if the slope window is out of bounds. Then look at the console and see where abs(firstfit - fitLR.b) varies. Then correct the window value, and comment the lines again.
		100*abs(firsterror - ParamTree.rmse)/abs(firsterror)=;
		if ((abs(firsterror - ParamTree.rmse)/abs(firsterror))*100 > slopewindow) // Window for extracting the power law fit window error. The window is normalized with respect to the first slope, and then mupltiplied by 100, to turn it into a percentage.
			{
				//outputcol = fit(col(A), col(S));
				range yy = outputcol[wks.maxrows/2+offset:i];
				yy = fit(col(A)[wks.maxrows/2+offset:i], col(S)[wks.maxrows/2+offset:i]);  // Not working with inputcols instead of col(S). Need to figure out why.
				//yy = fit(col(A)[wks.maxrows/2+offset:i], inputcols[wks.maxrows/2+offset:i]);
				beta = ParamTree.P; // The exponent beta, for the power law dependence of the mobility.
				beta = round(beta,1); // Round beta
				nlend;
				break;
			};
			else
				continue;
	}
	
	return beta;
}

function PlotSingle (string graphname, string Template, string TemplateGeneric, dataset Layers, int ColumnsNo, dataset Columns, dataset LineTypes, string previousworkbook, int LegendUpdate)
{
	if(exist(%(uid2name(range2uid(["%(graphname$)"]))$))==0) // if there is no graph for this type of measurement then create a new graph
	{
		// Check if the template exists, otherwise, use a generic one
		if (exist(Template$)!=-1)// if the template exists
			win -t p "%(Template$)"; // create a graph window using template
		else
			win -t p "%(TemplateGeneric$)"; // create a graph window using a generic template
		
		page.longname$ = graphname$; //this renames the active window (long name)
		page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
	};
	else
		win -a %(uid2name(range2uid(["%(graphname$)"]))$); // activate the graph window
		

	loop(j, 1, ColumnsNo)
	{
		win -a %(uid2name(range2uid(["%(previousworkbook$)"]))$); // Note that I cannot use "win -a %(previousworkbook$);" inside the function.
		range rI = [%H]1!wcol(Columns[j]); // range variable
		
		win -a %(uid2name(range2uid(["%(graphname$)"]))$); // activate the graph window
		page.active = Layers[j]; // activate Layer i
		switch (LineTypes(j)) // Case study
		{
			case 1: // If the string is "1", plot in the active layer as line plot
				layer.include(rI);  // plot in the active layer as line plot
				break;
			
			case 2: // If the string is "2", plot in the active layer as scatter plot
				layer -i201 rI;  // plot in the active layer as scatter plot
				break;
			
			default: // For all other cases, plot in the active layer as line plot
				layer.include(rI);  // plot in the active layer as line plot
				break;
		}
		
	};

	//layer -a;  // rescale the layer
	//layer -g; // Group the datasets in the layer to auto-color increment
	//layer -gu; // Ungroup the datasets in the layer
	if (LegendUpdate == 1)
		legend; // Update the legend
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------------
	string templatepath$ = "C:\Users\Administrator\Documents\OriginLab\2018\User Files\Templates\"; // define the template path
	string TemplateGeneric$;
	string graphname$;
	string Template$;
	dataset Columns;
	dataset LineTypes;
	int LegendUpdate;

	doc -ef LB { // loop over all workbooks in folder
		LegendUpdate = 1; // Set the legend to be updated when plotting a function.
		
		page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
		page.active = 1; // Switch to the first worksheet.
		
		string sheetname$=page.longname$; // Get the name of worksheet
		
		string batch$ = sheetname.GetToken(1,"_")$; // Get the string that shows the batch
		string architecture$ = sheetname.GetToken(2,"_")$; // Get the string that shows the architecture
		string material$ = sheetname.GetToken(3,"_")$; // Get the string that shows the material

		string concentration$ = sheetname.GetToken(4,"_")$; // Get the string that shows the concentration
		string concnumber$ = concentration.GetToken(1,"-")$; // Get the string that shows the concentration number
		string concunits$ = concentration.GetToken(2,"-")$; // Get the string that shows the concentration units

		string solvent$ = sheetname.GetToken(5,"_")$; // Get the string that shows the solvent content

		string annealing$ = sheetname.GetToken(6,"_")$; // Get the string that shows the additive

		string additive$ = sheetname.GetToken(7,"_")$; // Get the string that shows the additive
		string additivetype$ = additive.GetToken(1,"-")$; // Get the string that shows the additive type
		//string addthickness$ = additive.GetToken(2,"-")$; // Get the string that shows the additive thickness
		//string addthicknessunits$ = additive.GetToken(3,"-")$; // Get the string that shows the additive thickness units
		
		string dielectric$ = sheetname.GetToken(8,"_")$; // Get the string that shows the dielectric
		string dielectricconc$ = sheetname.GetToken(9,"_")$; // Get the string that shows the dielectric concentration or ratio

		string sampleNo$ = sheetname.GetToken(10,"_")$; // Get the string that shows the sample number

		string deviceNo$ = sheetname.GetToken(11,"_")$; // Get the string that shows the device number

		string length$ = sheetname.GetToken(12,"_")$; // Get the string that shows the channel length
		string lengthnumber$ = length.GetToken(1,"-")$; // Get the string that shows the length number
		string lengthunits$ = length.GetToken(2,"-")$; // Get the string that shows the length units

		//string stepNo$ = sheetname.GetToken(8,"_")$; // Get the string that shows the step number in the cycling process
		string condition$ = sheetname.GetToken(13,"_")$; // Get the string that shows the conditions (air/type of liquid)
		string timelength$ = sheetname.GetToken(14,"_")$; // get the string, which shows the number of days
		string minutesNo$ = timelength.GetToken(1,"-")$; // get the string, which shows the number of minutes
		string meastype$=sheetname.GetToken(15,"_")$; // Get the string "T" or "O", which shows if the curve is a transfer or output curve
		string measNo$=sheetname.GetToken(16,"_")$; // Get the string that shows the measurement number
		string mode$=sheetname.GetToken(17,"_")$; // Get the string that shows the measurement mode
		string intime$=sheetname.GetToken(18,"_")$; // Get the string that shows the integration time
		intime$=intime.GetToken(1,".")$; // Remove ".txt" from the integration time
		
		
		// Transfer curve parameters
		double W=1000; // Width [um]
		//double L=20; // Length [um]
		double L=%(lengthnumber$); // Length [um] (extracted from the file name)
		double d=3; // Thickness of accumulation layer [nm]
		double er=2.1; // Dielectric constant (CYTOP: 2.1, PMMA: 3.6, SiO2: 3.9)
		double e0=8.854E-12; // Vacuum permittivity [F/m]
		double dielectricthickness=550; // Dielectric thickness [nm]
		double Ci=e0*er/(dielectricthickness*10^(-9)); // Insulator capacitance per area [F/m^2]
		//double Ci=5.2E-5; // Ci for Cytop (Mark: 3.2 nF, 5.2 is for PMMA)
		
		double beta; // Parameter for power law dependence of the mobility
		double kappa; // The correction factor for the mobility
		
		// Rolling Regression function parameters
		int minRangeLength = 10; // The minimum range of voltages over which the linear fit will be applied.
		int minRangeLengthPLF = 20; // The minimum range of voltages over which the Power Law fit will be applied.		
		double offsetwindow = 10; // [%] Percentage of slope variation allowed before offset is declared. The offset determines if the fitting will start from Vgmax or from Vgmax+offset.
		double slopewindowlin = 1.2; // [%] Percentage of slope variation allowed before linear fit is performed. This is the "window" for perfoming the rolling regression. (Linear)
		double slopewindowsat = 3; // [%] Percentage of slope variation allowed before linear fit is performed. This is the "window" for perfoming the rolling regression. (Saturation)
		double slopewindowPLF = 20; // [%] Percentage of error variation allowed before power law fit is performed. This is the "window" for perfoming the power law fit. (Saturation)
		
		double jmaxlin; // Max channel current density (Linear)
		double jmaxsat; // Max channel current density (Saturation)
		double Pmaxlin; // Max channel power density (Linear)
		double Pmaxsat; // Max channel power density (Saturation)
		
		string Vdlin$; // Vd in the linear regime
		string Vdsat$; // Vd in the saturation regime
		double Vtlin; // Threshold voltage (Linear)
		double Vtsat; // Threshold voltage (Saturation)
		double rlin; // Reliability factor (Linear)
		double rsat; // Reliability factor (Saturation)
		
		string conunitslegend$; // This string will depend on "concunits" and it will display the concentration for the graph legend
		string additivegraphlegend$; // This string will depend on "additive" and it will display the type of additive for the graph legend
		string condgraphlegend$; // This string will depend on "condition" and it will display the type of condition for the graph legend
		string timegraphlegend$; // This string will depend on "minutesNo" and it will display the number of minutes for the graph legend
		string modegraphlegend$; // This string will depend on "mode" and it will display the measurement mode for the graph legend
		string intimegraphlegend$; // This string will depend on "intime" and it will display the integration time for the graph legend

//-----------------------------------------------------------------------------------------------------------------------------------------------------------
		// Check for NaN columns
		range rb = [%H]1!wcol(2);  // data range of (Is) (Vd=Vdlin) column (col(B))
		range rc = [%H]1!wcol(3);  // data range of (Is) (Vd=Vdsat) column (col(C))
		
		string NaNb$ = Lookup("NaN", rb)$;
		string NaNc$ = Lookup("NaN", rc)$;
		
		if(Nanb$=="NaN" || Nanc$=="NaN" || exist(%H,2)==0) continue; // If object does not exist or if "NaN" is present, then just continue to the next workbook. When LabVIEW measurements are interrupted, they yield NaN values.
			else
			{
				//-----------------------------------------------------------------------------------------------------------------------------------------------------------
				// Case structures from filenames (used for legends).
				
				
				conunitslegend$ = findConcunits(concunits$)$; // Note ending '$'
				additivegraphlegend$ = findAdditive(additive$)$; // Note ending '$'
				condgraphlegend$ = findCondition(condition$)$; // Note ending '$'
				timegraphlegend$ = findTime(timelength$)$; // Note ending '$'
				modegraphlegend$ = findMode(mode$)$; // Note ending '$'
				intimegraphlegend$ = findInTime(intime$)$; // Note ending '$'
				
				
				//string legend$ = "%(material$) %(concnumber$) %(conunitslegend$) %(additivegraphlegend$), %(condgraphlegend$), %(timegraphlegend$), %(minutesgraphlegend$), %(modegraphlegend$), %(intimegraphlegend$)"; // Legend
				string legend$ = "%(condgraphlegend$), %(timegraphlegend$)"; // Legend
				//-----------------------------------------------------------------------------------------------------------------------------------------------------------
				
				string previousworkbook$=%H; // Get the name of the current window and store it in previousworkbook$
				
				if (meastype$ == "T") // if this is a transfer curve then
				{
						wks.name$=Transfer; // Change the sheet name to "Transfer"
						wks.ncols=41; // set total column number to 41
						wks.colwidth = 10;// set all col width to 10
						
						// Extract Vdlin and Vdsat
						Vdlin$=col(D)[L]$;
						Vdlin$=Vdlin.GetToken(2,"=")$; // Take the string on the right of the "=" sign
						Vdlin$=Vdlin.GetToken(1,"V")$; // Take the string on the left of the "V" (units)
						if (Vdlin.Find('.')!=0 && Vdlin.GetToken(2,".")$ == "0")
							Vdlin$=Vdlin.GetToken(1,".")$; // Take the string on the left of the "." (this line gets rid of the decimal points if the right digit is 0)
						
						
						Vdsat$=col(E)[L]$;
						Vdsat$=Vdsat.GetToken(2,"=")$; // Take the string on the right of the "=" sign
						Vdsat$=Vdsat.GetToken(1,"V")$; // Take the string on the left of the "V" (units)
						if (Vdsat.Find('.')!=0 && Vdsat.GetToken(2,".")$ == "0")
							Vdsat$=Vdsat.GetToken(1,".")$; // Take the string on the left of the "." (this line gets rid of the decimal points if the right digit is 0)
						
						
						// Extract VgStart and VgStop
						string VgStart$=$(col(A)[1]); // VgStart is the value of the first cell of col(A)
						string VgStop$=$(col(A)[wks.maxrows/2]); // VgStop is the middle cell of col(A) (assuming the gate voltage has a forward and reverse sweep) - wks.maxrows is the total number of (non-empty) rows
						
						
						// Write long name, units, comments, and parameters of columns
						col(H)[L]$ = col(D)[L]$; // Long name
						col(H)[U]$ = col(D)[U]$; // Units
						col(H)[O]$ = "abs(col(D))";
						col(I)[L]$ = col(E)[L]$; // Long name
						col(I)[U]$ = col(E)[U]$; // Units
						col(I)[O]$ = "abs(col(E))";
						col(J)[L]$ = col(F)[L]$; // Long name
						col(J)[U]$ = col(F)[U]$; // Units
						col(J)[O]$ = "abs(col(F))";
						col(K)[L]$ = col(G)[L]$; // Long name
						col(K)[U]$ = col(G)[U]$; // Units
						col(K)[O]$ = "abs(col(G))";
						
						
						
						col(L)[L]$ = "gm (Linear)"; // Long name
						col(L)[U]$ = S; // Units
						differentiate iy:=Col(H) oy:=Col(L) order:=1;
						col(L)[O]$ = "abs(col(L))";
						col(L)[C]$ = "abs(d(Id (Vd=%(Vdlin$)V)/dV)";
						
						col(M)[L]$ = "Mobility (Linear)"; // Long name
						col(M)[U]$ = cm^2/V*s; // Units
						col(M) = 10000*L*col(L)/(W*Ci*abs(%(Vdlin$))); // The multiplication by 10000 is done to get the mobility in cm^2/Vs, instead of m^2/Vs.
						
						// The average mobilities are derived by using the linear fit of the slope of the Id (SQRT(Id)) in the Linear (Saturation) regime, instead of the point derivative.
						
						col(N)[L]$ = "Linear fit on Id (Vd=%(Vdlin$)V)"; // Long name
						col(N)[U]$ = A; // Units
						range rRGlinIy = [%H]1!col(H); // Define the range variable (Vg column, d(Id(Vdlin))/dV column) for the input argument of the rolling regression function.
						range rRGlinOy = [%H]1!col(N); // Define the range variable (linear fit output column) for the input argument of the rolling regression function.
						Vtlin = RollingRegression(rRGlinIy, rRGlinOy, minRangeLength, slopewindowlin, offsetwindow); // Rolling Regression function that returns Vtsat. Inputs arguments are (Vg column, SQRT(Id) column, minRangelength variable, offset variable, slope window variable).
						
						
						// Linear extrapolation of the linear fit, to find the intercept with the X axis
						range rn=(1,14); // Define XYrange
						col(N)=rn(col(A)); // Extrapolate for new X axis (col(A))
						
						
						// The average mobilities are derived by using the linear fit of the slope of the Id d(SQRT(Id(Vdsat)))/dV in the Linear (Saturation) regime, instead of the point derivative.
						col(O)[L]$ = "Average mobility (Linear)"; // Long name
						col(O)[U]$ = cm^2/V*s; // Units
						col(O)[1] = 10000*L*abs(fitLR.b)/(W*Ci*abs(%(Vdlin$))); // The multiplication by 10000 is done to get the mobility in cm^2/Vs, instead of m^2/Vs.
						ulinavg=col(O)[1];
						
						col(P)[L]$ = "Threshold voltage (Linear)"; // Long name
						col(P)[U]$ = V; // Units
						Col(P)[1]=Vtlin; // Threshold voltage (Linear)
						
						
						
						col(Q)[L]$ = "SQRT(Id (Vd=%(Vdsat$)V))"; // Long name
						col(Q)[U]$ = A^(1/2); // Units
						col(Q)[O]$ = "sqrt(col(I))";
						
						col(R)[L]$ = "gm (Saturation)"; // Long name
						col(R)[U]$ = S; // Units
						differentiate iy:=Col(Q) oy:=Col(R) order:=1;
						col(R)[O]$ = "abs(col(R))";
						col(R)[C]$ = "abs(d(SQRT(Id (Vd=%(Vdsat$)V))/dV)";
						
						col(S)[L]$ = "Mobility (Saturation)"; // Long name
						col(S)[U]$ = cm^2/V*s; // Units
						col(S) = 10000*2*L*col(R)^2/(W*Ci); // The multiplication by 10000 is done to get the mobility in cm^2/Vs, instead of m^2/Vs.
						
						col(T)[L]$ = "Linear fit on SQRT(Id (Vd=%(Vdsat$)V))"; // Long name
						col(T)[U]$ = A^(1/2); // Units
						range rRGsatIy = [%H]1!col(Q); // Define the range variable (Vg column, SQRT(Id) column) for the input argument of the rolling regression function.
						range rRGsatOy = [%H]1!col(T); // Define the range variable (linear fit output column) for the input argument of the rolling regression function.
						Vtsat = RollingRegression(rRGsatIy, rRGsatOy, minRangeLength, slopewindowsat, offsetwindow); // Rolling Regression function that returns Vtsat. Inputs arguments are (Vg column, SQRT(Id) column, minRangelength variable, offset variable, slope window variable).
						
						// Linear extrapolation of the linear fit, to find the intercept with the X axis
						range rt=(1,20); // Define XYrange
						col(T)=rt(col(A)); // Extrapolate for new X axis (col(A))
						
						
						// The average mobilities are derived by using the linear fit of the slope of the Id (SQRT(Id)) in the Linear (Saturation) regime, instead of the point derivative.
						col(U)[L]$ = "Average mobility (Saturation)"; // Long name
						col(U)[U]$ = cm^2/V*s; // Units
						col(U)[1] = 10000*2*L*fitLR.b^2/(W*Ci); // The multiplication by 10000 is done to get the mobility in cm^2/Vs, instead of m^2/Vs.
						usatavg=col(U)[1];
						
						col(V)[L]$ = "Threshold voltage (Saturation)"; // Long name
						col(V)[U]$ = V; // Units
						Col(V)[1] = Vtsat; // Threshold voltage (Saturation)
						
						
						//-----------------------------------------------------------------------------------------------------------------------------------------------------------
						
						// Reliability factors
						
						// Find the average linear drain current for Vg=0V: Id,lin (Vd=0V)
						col(W)[L]$ = "Row number for Vg=0"; // Long name
						vfind ix:=col(A) value:=0 ox:=Col(W); // Find all indices for which Vg=0
						
						
						
						col(X)[L]$ = "Id,lin (Vg=0V)"; // Long name
						col(X)[U]$ = A; // Units
						col(X)[1]=col(H)[col(W)[1]];
						col(X)[2]=col(H)[col(W)[2]];
						double IdlinVg0=mean(col(X));
						col(X)[3]=IdlinVg0; // The average Id,lin (Vg=0V)
						wcellcolor col(X)[3] color(yellow); // Color the cell with the average value yellow
						
						
						col(Y)[L]$ = "Id,sat (Vg=0V)"; // Long name
						col(Y)[U]$ = A; // Units
						col(Y)[1]=col(I)[col(W)[1]];
						col(Y)[2]=col(I)[col(W)[2]];
						double IdsatVg0=mean(col(Y));
						col(Y)[3]=IdsatVg0; // The average Id,sat (Vg=0V)
						wcellcolor col(Y)[3] color(yellow); // Color the cell with the average value yellow
						
						
						// Reliability factor (Linear)
						col(Z)[L]$ = "Reliability factor (Linear)"; // Long name
						col(Z)[U]$ = %; // Units
						rlin = 100*(max(col(H))-IdlinVg0)/max(abs(col(A)))/max(abs(col(L))); // Multiply by 100, since the units are %
						rlin = round(rlin,1);
						
						// Write rlin on the first cell of col(Z)
						col(Z)[1]=rlin;
						
						// Reliability factor (Saturation)
						col(AA)[L]$ = "Reliability factor (Saturation)"; // Long name
						col(AA)[U]$ = %; // Units
						rsat = 100*((max(col(Q))-SQRT(IdsatVg0)))^2/max(abs(col(A)))^2/max(abs(col(R)))^2; // Multiply by 100, since the units are %
						rsat = round(rsat,1);
						
						// Write rsat on the first cell of col(W)
						col(AA)[1]=rsat;
						
						
						//-----------------------------------------------------------------------------------------------------------------------------------------------------------
						
						// Current density and power density
						col(AB)[L]$ = "Max channel current density (Linear)"; // Long name
						col(AB)[U]$ = A/cm^2; // Units
						col(AB)[1] = max(col(H))/(W*10^(-4)*d*10^(-7)); // W is in um and d in nm. They are both converted to cm.
						jmaxlin=col(AB)[1];
						
						col(AC)[L]$ = "Max channel current density (Saturation)"; // Long name
						col(AC)[U]$ = A/cm^2; // Units
						col(AC)[1] = max(col(I))/(W*10^(-4)*d*10^(-7)); // W is in um and d in nm. They are both converted to cm.
						jmaxsat=col(AC)[1];
						
						col(AD)[L]$ = "Max channel power density (Linear)"; // Long name
						col(AD)[U]$ = W/cm^2; // Units
						col(AD)[1] = max(col(H))*abs(%(Vdlin$))/(W*10^(-4)*L*10^(-4)); // W and L are in um, and are both converted to cm.
						Pmaxlin=col(AD)[1];
						
						col(AE)[L]$ = "Max channel power density (Saturation)"; // Long name
						col(AE)[U]$ = W/cm^2; // Units
						col(AE)[1] = max(col(I))*abs(%(Vdsat$))/(W*10^(-4)*L*10^(-4)); // W and L are in um, and are both converted to cm.
						Pmaxsat=col(AE)[1];
						
						//-----------------------------------------------------------------------------------------------------------------------------------------------------------
						// Max source-drain electric field (Saturation)
						// NOTE: This should be smaller than 3*10^4 V/cm (DOI: 10.1038/nmat5035)
						
						col(AF)[L]$ = "Max source-drain electric field (Saturation)"; // Long name
						col(AF)[U]$ = V/cm; // Units
						col(AF)[1] = abs(%(Vdsat$))/(L*10^(-4)); // W and L are in um, and are both converted to cm.
						Esd=col(AF)[1];
						
						//-----------------------------------------------------------------------------------------------------------------------------------------------------------
						
						// Contact resistance (Riccardo di Pietro's model, DOI: 10.1063/1.4876057)
						
						col(AG)[L]$ = "Average linear current"; // Long name
						col(AG)[U]$ = A; // Units
						col(AG)[O]$ = "abs(col(B)-col(D))/2";
						
						col(AH)[L]$ = "Error"; // Long name
						col(AH)[U]$ = A; // Units
						col(AH)[O]$ = "col(F)/2 + col(AG)*0.01";
						
						col(AI)[L]$ = "Average saturation current"; // Long name
						col(AI)[U]$ = A; // Units
						col(AI)[O]$ = "abs(col(C)-col(E))/2";
						
						col(AJ)[L]$ = "Error"; // Long name
						col(AJ)[U]$ = A; // Units
						col(AJ)[O]$ = "col(G)/2 + col(AI)*0.01";
						
						//col(AG)[L]$ = "d(Id (Vd=%(Vdsat$)V)/dV"; // Long name
						//col(AG)[U]$ = S; // Units
						//differentiate iy:=Col(AE) oy:=Col(AG) order:=1;
						
						col(AK)[L]$ = "d(Id (Vd=%(Vdsat$)V)/dV"; // Long name
						col(AK)[U]$ = S; // Units
						differentiate iy:=Col(I) oy:=Col(AK) order:=1;
						
						col(AL)[L]$ = "Rc"; // Long name
						col(AL)[U]$ = Ohm; // Units
						col(AL)[O]$ = "abs(%(Vdlin$)/col(AG) - 1/col(AK))";
						
						//col(AL)[L]$ = "Contact resistance"; // Long name
						//col(AL)[U]$ = Ohm; // Units
						//col(AL)[O]$ = "abs(%(Vdlin$)/col(H) - 1/col(AK))";
						
						col(AM)[L]$ = "Error"; // Long name
						col(AM)[U]$ = A; // Units
						col(AM)[O]$ = "col(AL)*2*sqrt((col(AJ)/col(AI))^2+(col(AH)/col(AG))^2)";
						
						col(AN)[L]$ = "Channel voltage"; // Long name
						col(AN)[U]$ = V; // Units
						col(AN)[O]$ = "col(AG)/col(AK)";
						
						//col(AN)[L]$ = "Channel voltage"; // Long name
						//col(AN)[U]$ = V; // Units
						//col(AN)[O]$ = "col(H)/col(AK)";
						
						col(AO)[L]$ = "Error"; // Long name
						col(AO)[U]$ = A; // Units
						col(AO)[O]$ = "col(AN)*2*sqrt((col(AJ)/col(AI))^2+(col(AH)/col(AG))^2)";
						
						//-----------------------------------------------------------------------------------------------------------------------------------------------------------
						
						// Mobility correction (Riccardo di Pietro's model, DOI: 10.1063/1.4876057)
						// NOTE: This tends to fail a lot when the mobility is not exponentially dependent on the gate voltage... It can produce an Origin C error (349) in X-Function code.
						
						col(AP)[L]$ = "Power law fit (Saturation mobility)"; // Long name
						col(AP)[U]$ = cm^2/V*s; // Units
						
						range rPLFusatIy = [%H]1!col(S); // Define the range variable (Vg column, usat column) for the input argument of the rolling regression function.
						range rPLFusatOy = [%H]1!col(AP); // Define the range variable (power law fit output column) for the input argument of the rolling regression function.
						beta = PowerLawFit(rPLFusatIy, rPLFusatOy, minRangeLengthPLF, slopewindowPLF); // Power Law Fit function that returns the exponent beta. Inputs arguments are (Vg column, SQRT(Id) column, minRangelength variable, offset variable, slope window variable).
						kappa = (beta + 2)/(2*(beta+1)); // The correction factor, kappa.
						
						col(AQ)[L]$ = "Beta"; // Long name
						col(AQ)[1] = beta; // The exponent from the power law fitting.
						
						col(AR)[L]$ = "Correction factor"; // Long name
						col(AR)[1] = kappa; // The calculated correction factor.
						
						col(AS)[L]$ = "Corrected mobility (Saturation)"; // Long name
						col(AS)[U]$ = cm^2/V*s; // Units
						col(AS) = col(S)/kappa; // The corrected mobility is the original mobility, divided by the correction factor.
						
						//-----------------------------------------------------------------------------------------------------------------------------------------------------------
						// Column legends
						
						col(H)[C]$ = legend$;
						col(I)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(J)[C]$ = col(H)[C]$ + ", Leakage"; // Comment field (graph legend)
						col(K)[C]$ = col(H)[C]$ + ", Leakage"; // Comment field (graph legend)
						col(L)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(M)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(N)[C]$ = col(H)[C]$ + ", Linear fit"; // Comment field (graph legend)
						col(Q)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(R)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(S)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(T)[C]$ = col(Q)[C]$ + ", Linear fit"; // Comment field (graph legend)
						col(V)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(AL)[C]$ = col(H)[C]$; // Comment field (graph legend)
						
						col(AP)[C]$ = col(H)[C]$ + ", Power law fit"; // Comment field (graph legend)
						col(AS)[C]$ = col(H)[C]$; // Comment field (graph legend)
						
						//-----------------------------------------------------------------------------------------------------------------------------------------------------------
						// Plot graphs
						
						
						// Plot linear transfer curve
						TemplateGeneric$ = "%(templatepath$)Generic_Transfer_single.otpu";
						graphname$ = "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_Transfer_Vd=%(Vdlin$)V";
						Template$ = "%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_Transfer_Leakage_Vd=%(Vdlin$)V_Vg=%(VgStart$)V to %(VgStop$)V_single.otpu"; // This is the template path
						Layers = {1, 1};
						Columns = {8, 10};
						LineTypes = {1, 1}; // 1 for line plot, 2 for scatter plot
						PlotSingle(graphname$, Template$, TemplateGeneric$, Layers, 2, Columns, LineTypes, previousworkbook$, LegendUpdate);
						
						
						// Plot saturation transfer curve
						graphname$ = "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_Transfer_Vd=%(Vdsat$)V";
						Template$ = "%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_Transfer_Leakage_Vd=%(Vdsat$)V_Vg=%(VgStart$)V to %(VgStop$)V_single.otpu"; // This is the template path
						Columns = {9, 11};
						PlotSingle(graphname$, Template$, TemplateGeneric$, Layers, 2, Columns, LineTypes, previousworkbook$, LegendUpdate);
						
						
						// Plot gm (Linear)
						TemplateGeneric$ = "%(templatepath$)Generic_gm-lin.otpu";
						graphname$ = "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_gm-lin_Vd=%(Vdlin$)V";
						Template$ = "%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_gm-lin_Vd=%(Vdlin$)V_Vg=%(VgStart$)V to %(VgStop$)V_single.otpu"; // This is the template path
						Layers = {1};
						Columns = {12};
						LineTypes = {1}; // 1 for line plot, 2 for scatter plot
						PlotSingle(graphname$, Template$, TemplateGeneric$, Layers, 1, Columns, LineTypes, previousworkbook$, LegendUpdate);
						if (exist(Text2,16)==16) Text2.text$ = r\-(lin)=$(rlin) %; // If the label exists, update it
						if (exist(Text3,16)==16) Text3.text$ = J\-(ch,max,lin)=$(jmaxlin, .1) A/cm\+(2); // If the label exists, update it
						if (exist(Text4,16)==16) Text4.text$ = P\-(ch,max,lin)=$(Pmaxlin, .1) W/cm\+(2); // If the label exists, update it
						plot -c; // refresh the graph to update the labels
						
						
						// Plot gm (Saturation)
						TemplateGeneric$ = "%(templatepath$)Generic_gm-sat.otpu";
						graphname$ = "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_gm-sat_Vd=%(Vdsat$)V";
						Template$ = "%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_gm-sat_Vd=%(Vdsat$)V_Vg=%(VgStart$)V to %(VgStop$)V_single.otpu"; // This is the template path
						Columns = {18};
						PlotSingle(graphname$, Template$, TemplateGeneric$, Layers, 1, Columns, LineTypes, previousworkbook$, LegendUpdate);
						if (exist(Text2,16)==16) Text2.text$ = r\-(sat)=$(rsat) %; // If the label exists, update it
						if (exist(Text3,16)==16) Text3.text$ = J\-(ch,max,sat)=$(jmaxsat, .1) A/cm\+(2); // If the label exists, update it
						if (exist(Text4,16)==16) Text4.text$ = P\-(ch,max,sat)=$(Pmaxsat, .1) W/cm\+(2); // If the label exists, update it
						plot -c; // refresh the graph to update the labels
						
						
						// Plot mobility (Linear)
						TemplateGeneric$ = "%(templatepath$)Generic_u-lin.otpu";
						graphname$ = "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_u-lin_Vd=%(Vdlin$)V";
						Template$ = "%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_u-lin_Vd=%(Vdlin$)V_Vg=%(VgStart$)V to %(VgStop$)V_single.otpu"; // This is the template path
						Layers = {1};
						Columns = {13};
						LineTypes = {2}; // 1 for line plot, 2 for scatter plot
						PlotSingle(graphname$, Template$, TemplateGeneric$, Layers, 1, Columns, LineTypes, previousworkbook$, LegendUpdate);
						if (exist(Text2,16)==16) Text2.text$ = r\-(lin)=$(rlin) %; // If the label exists, update it
						if (exist(Text3,16)==16) Text3.text$ = J\-(ch,max,lin)=$(jmaxlin, .1) A/cm\+(2); // If the label exists, update it
						if (exist(Text4,16)==16) Text4.text$ = P\-(ch,max,lin)=$(Pmaxlin, .1) W/cm\+(2); // If the label exists, update it
						plot -c; // refresh the graph to update the labels
						
						
						// Plot mobility (Saturation)
						TemplateGeneric$ = "%(templatepath$)Generic_u-sat.otpu";
						graphname$ = "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_u-sat_Vd=%(Vdsat$)V";
						Template$ = "%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_u-sat_Vd=%(Vdsat$)V_Vg=%(VgStart$)V to %(VgStop$)V_single.otpu"; // This is the template path
						Columns = {19};
						PlotSingle(graphname$, Template$, TemplateGeneric$, Layers, 1, Columns, LineTypes, previousworkbook$, LegendUpdate);
						if (exist(Text2,16)==16) Text2.text$ = r\-(sat)=$(rsat) %; // If the label exists, update it
						if (exist(Text3,16)==16) Text3.text$ = J\-(ch,max,sat)=$(jmaxsat, .1) A/cm\+(2); // If the label exists, update it
						if (exist(Text4,16)==16) Text4.text$ = P\-(ch,max,sat)=$(Pmaxsat, .1) W/cm\+(2); // If the label exists, update it
						plot -c; // refresh the graph to update the labels
						
						
						// Plot corrected mobility (Saturation)
						TemplateGeneric$ = "%(templatepath$)Generic_u-sat-cor.otpu";
						graphname$ = "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_u-sat-cor_Vd=%(Vdsat$)V";
						Template$ = "%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_u-sat-cor_Vd=%(Vdsat$)V_Vg=%(VgStart$)V to %(VgStop$)V_single.otpu"; // This is the template path
						Columns = {45};
						PlotSingle(graphname$, Template$, TemplateGeneric$, Layers, 1, Columns, LineTypes, previousworkbook$, LegendUpdate);
						if (exist(Text2,16)==16) Text2.text$ = r\-(sat)=$(rsat) %; // If the label exists, update it
						if (exist(Text3,16)==16) Text3.text$ = J\-(ch,max,sat)=$(jmaxsat, .1) A/cm\+(2); // If the label exists, update it
						if (exist(Text4,16)==16) Text4.text$ = P\-(ch,max,sat)=$(Pmaxsat, .1) W/cm\+(2); // If the label exists, update it
						if (exist(Text5,16)==16) Text5.text$ = \g(b)=$(beta, .2); // If the label exists, update it
						if (exist(Text6,16)==16) Text6.text$ = \g(k)=$(kappa, .2); // If the label exists, update it
						plot -c; // refresh the graph to update the labels
						
						
						// Plot joint mobility graph
						TemplateGeneric$ = "%(templatepath$)Generic_u-lin-sat.otpu";
						graphname$ = "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_u-lin-sat_Vd=%(Vdsat$)V";
						Template$ = "%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_u-lin-sat_Vd=%(Vdsat$)V_Vg=%(VgStart$)V to %(VgStop$)V_single.otpu"; // This is the template path
						Layers = {1, 1};
						Columns = {13, 19};
						LineTypes = {2, 2}; // 1 for line plot, 2 for scatter plot
						PlotSingle(graphname$, Template$, TemplateGeneric$, Layers, 2, Columns, LineTypes, previousworkbook$, LegendUpdate);
						if (exist(Text2,16)==16) Text2.text$ = r\-(lin)=$(rlin) %; // If the label exists, update it
						if (exist(Text3,16)==16) Text3.text$ = J\-(ch,max,lin)=$(jmaxlin, .1) A/cm\+(2); // If the label exists, update it
						if (exist(Text4,16)==16) Text4.text$ = P\-(ch,max,lin)=$(Pmaxlin, .1) W/cm\+(2); // If the label exists, update it
						if (exist(Text5,16)==16) Text5.text$ = r\-(sat)=$(rsat) %; // If the label exists, update it
						if (exist(Text6,16)==16) Text6.text$ = J\-(ch,max,sat)=$(jmaxsat, .1) A/cm\+(2); // If the label exists, update it
						if (exist(Text7,16)==16) Text7.text$ = P\-(ch,max,sat)=$(Pmaxsat, .1) W/cm\+(2); // If the label exists, update it
						plot -c; // refresh the graph to update the labels
						
						
						// Plot linear fit of Idlin and linear extrapolation (for Vt)
						TemplateGeneric$ = "%(templatepath$)Generic_Vt-lin.otpu";
						graphname$ = "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_Vt-lin_Vd=%(Vdlin$)V";
						Template$ = "%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_Vt-lin_Vd=%(Vdlin$)V_Vg=%(VgStart$)V to %(VgStop$)V_single.otpu"; // This is the template path
						Layers = {1, 1};
						Columns = {8, 14};
						LineTypes = {1, 1}; // 1 for line plot, 2 for scatter plot
						PlotSingle(graphname$, Template$, TemplateGeneric$, Layers, 2, Columns, LineTypes, previousworkbook$, LegendUpdate);
						layer.y.from=0; // place the "From" scale of the Y axis from 0, to show clearly the intercept of the linear fit with the X axis
						if (exist(Text2,16)==16) Text2.text$ = V\-(t,lin) = $(Vtlin)V;
						plot -c; // refresh the graph to update the labels
						
						
						// Plot linear fit of SQRT(Idsat) and linear extrapolation (for Vt)
						TemplateGeneric$ = "%(templatepath$)Generic_Vt-sat.otpu";
						graphname$ = "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_Vt-sat_Vd=%(Vdsat$)V";
						Template$ = "%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_Vt-sat_Vd=%(Vdsat$)V_Vg=%(VgStart$)V to %(VgStop$)V_single.otpu"; // This is the template path
						Columns = {17, 20};
						PlotSingle(graphname$, Template$, TemplateGeneric$, Layers, 2, Columns, LineTypes, previousworkbook$, LegendUpdate);
						layer.y.from=0; // place the "From" scale of the Y axis from 0, to show clearly the intercept of the linear fit with the X axis
						if (exist(Text2,16)==16) Text2.text$ = V\-(t,sat)= $(Vtsat)V;
						plot -c; // refresh the graph to update the labels
						
						
						// Plot contact resistance (Linear)
						TemplateGeneric$ = "%(templatepath$)Generic_Rc-lin.otpu";
						graphname$ = "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_Rc-lin_Vd=%(Vdlin$)V";
						Template$ = "%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_Rc-lin_Vd=%(Vdlin$)V_Vg=%(VgStart$)V to %(VgStop$)V.otpu"; // This is the template path
						Layers = {1};
						Columns = {38};
						LineTypes = {1}; // 1 for line plot, 2 for scatter plot
						PlotSingle(graphname$, Template$, TemplateGeneric$, Layers, 1, Columns, LineTypes, previousworkbook$, LegendUpdate);
						
						
						// Check if the measurement is the last measurement of this device
						string nextmeassheetname$="%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_%(meastype$)_$(%(measNo$)+1)_%(mode$)_%(intime$).txt";
						if(exist(%(uid2name(range2uid(["%(nextmeassheetname$)"]))$))!=0){
							win -a %(previousworkbook$);  // activate the previous window (workbook)
							window -ch 1; // hide the transfer workbook that was processed
							continue; // if this is not the last measurement of its kind, then continue to the next iteration
						};
						
						
						// Plot joint transfer curve - SQRT(Idsat) graph
						TemplateGeneric$ = "%(templatepath$)Generic_Transfer_Vt-sat.otpu";
						graphname$ = "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_Transfer_Vd=%(Vdlin$),%(Vdsat$)V_Vt-sat_Vd=%(Vdsat$)V";
						Template$ = "%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_Transfer_Vd=%(Vdlin$),%(Vdsat$)V_Vt-sat_Vd=%(Vdsat$)V_Vg=%(VgStart$)V to %(VgStop$)V_single.otpu"; // This is the template path
						Layers = {1, 1, 2, 2};
						Columns = {8, 9, 17, 20};
						LineTypes = {1, 1, 1, 1}; // 1 for line plot, 2 for scatter plot
						LegendUpdate = 0; // Do not update the legend
						PlotSingle(graphname$, Template$, TemplateGeneric$, Layers, 4, Columns, LineTypes, previousworkbook$, LegendUpdate);
						LegendUpdate = 1; // Do not update the legend
						page.active = 1; // activate Layer 1
						if (exist(Text3,16)==16) Text3.text$ = (V\-(d) = %(Vdlin$)V);
						if (exist(Text4,16)==16) Text4.text$ = (V\-(d) = %(Vdsat$)V);
						if (exist(Text5,16)==16) Text5.text$ = at V\-(d) = %(Vdsat$)V;
						if (exist(Text,16)==16) Text.text$ = V\-(t,sat) = $(Vtsat)V; //(NOTE: The "Vt" label of the template is assumed to be on Layer 1.)
						page.active = 2; // activate Layer 2
						layer.y.from=0; // place the "From" scale of the Y axis from 0, to show clearly the intercept of the linear fit with the X axis
						
						
						// Plot Power law fit (Saturation) for the last measurement of the sample
						TemplateGeneric$ = "%(templatepath$)Generic_u-sat-PLF.otpu";
						graphname$ = "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_u-sat-PLF_Vd=%(Vdsat$)V";
						Template$ = "%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_u-sat-PLF_Vd=%(Vdsat$)V_Vg=%(VgStart$)V to %(VgStop$)V_single.otpu"; // This is the template path
						Layers = {1, 1, 1};
						Columns = {19, 42, 45};
						LineTypes = {2, 1, 2}; // 1 for line plot, 2 for scatter plot
						PlotSingle(graphname$, Template$, TemplateGeneric$, Layers, 3, Columns, LineTypes, previousworkbook$, LegendUpdate);
						if (exist(Text2,16)==16) Text2.text$ = r\-(sat)=$(rsat) %; // If the label exists, update it
						if (exist(Text3,16)==16) Text3.text$ = J\-(ch,max,sat)=$(jmaxsat, .1) A/cm\+(2); // If the label exists, update it
						if (exist(Text4,16)==16) Text4.text$ = P\-(ch,max,sat)=$(Pmaxsat, .1) W/cm\+(2); // If the label exists, update it
						if (exist(Text5,16)==16) Text5.text$ = \g(b)=$(beta, .2); // If the label exists, update it
						if (exist(Text6,16)==16) Text6.text$ = \g(k)=$(kappa, .2); // If the label exists, update it
						plot -c; // refresh the graph to update the labels
						
				};
				
				win -a %(previousworkbook$);  // activate the previous window (workbook)
				window -ch 1; // hide the transfer workbook that was processed
				
				//-----------------------------------------------------------------------------------------------------------------------------------------------------------
				else // if this is an output curve
				{						
					wks.name$=Output; // Change the sheet name to "Output"
					int NoofVgs = (wks.ncols-1)/3; // The number of different Vg voltages is going to be equal to the total No of columns, minus the gate voltage column, divided by 3 (as there are three currents for each Vg: Is, Id, Ig).
					wks.ncols = wks.ncols + NoofVgs*2;  // The number of columns will be equal to the old one plus two new columns for each Vg (one for abs(Id) and one for abs(Ig)).						
					wks.colwidth = 8;// set all col width to 8
					
					
					// Extract VdStart and VdStop
					string VdStart$= $(col(A)[1]); // VdStart is the value of the first cell of col(A)						
					string VdStop$=$(col(A)[wks.maxrows/2]); // VdStop is the middle cell of col(A) (assuming the gate voltage has a forward and reverse sweep) - wks.maxrows is the total number of (non-empty) rows
					
					
					loop(i,1,NoofVgs)
						{
							string previousworkbook$=%H; // Get the name of the previous window
							
							// Extract Vg							
							string Vg$=wcol(i+1)[L]$; // Start from column 2
							Vg$=Vg.GetToken(2,"=")$; // Take the string on the right of the "=" sign
							Vg$=Vg.GetToken(1,"V")$; // Take the string on the left of the "V" (units)
							if (Vg.Find('.')!=0 && Vg.GetToken(2,".")$ == "0")
								Vg$=Vg.GetToken(1,".")$; // Take the string on the left of the "." (this line gets rid of the decimal points if the right digit is 0)
							
							
							// Create a new column for abs(Id)
							wcol(i+NoofVgs+1+2*NoofVgs)[L]$ = col(%(i+NoofVgs+1))[L]$; // First Id column is i+NoofVgs+1. First empty column on the right is i+NoofVgs+1+2*NoofVgs. abs(Id(Vg)) and Id(Vg) will have a distance of 2*NoofVgs (e.g. col(N) will be ans(col(F)) if NoofVgs is 4)
							wcol(i+NoofVgs+1+2*NoofVgs)[U]$ = A; // Units
							wcol(i+NoofVgs+1+2*NoofVgs)[O]$ = "abs(col(%(i+NoofVgs+1)))";
							wcol(i+NoofVgs+1+2*NoofVgs)[C]$ =  "Vg=%(Vg$)V, %(legend$)";
							
							
							// Create a new column for abs(Ig)
							wcol(i+NoofVgs+1+3*NoofVgs)[L]$ = col(%(i+2*NoofVgs+1))[L]$; // abs(Ig) column will be NoofVgs further away from abs(Id)
							wcol(i+NoofVgs+1+3*NoofVgs)[U]$ = A; // Units
							wcol(i+NoofVgs+1+3*NoofVgs)[O]$ = "abs(col(%(i+2*NoofVgs+1)))";
							wcol(i+NoofVgs+1+3*NoofVgs)[C]$ =  "Vg=%(Vg$)V, %(legend$), Leakage";
							
							
							// Plot output curve
							range rId = [%H]1!wcol(i+NoofVgs+1+2*NoofVgs);  // data range of abs(Id) column
							range rIg = [%H]1!wcol(i+NoofVgs+1+3*NoofVgs);  // data range of abs(Ig) column
							
							// Output plot with all the Id
							TemplateGeneric$ = "%(templatepath$)Generic_Output.otpu";
							graphname$ = "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_Output";
							Template$ = "%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_Output_Vd=%(VdStart$)V to %(VdStop$)V.otpu"; // This is the template path
							Layers = {1};
							Columns = {i+NoofVgs+1+2*NoofVgs};
							LineTypes = {1}; // 1 for line plot, 2 for scatter plot
							PlotSingle(graphname$, Template$, TemplateGeneric$, Layers, 1, Columns, LineTypes, previousworkbook$, LegendUpdate);
							
							
							// Individual output plot with a single Id and Ig
							TemplateGeneric$ = "%(templatepath$)Generic_Output_single.otpu";
							graphname$ = "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_Output_Vg=%(Vg$)V";
							Template$ = "%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_Output_Leakage_Vg=%(Vg$)V_Vd=%(VdStart$)V to %(VdStop$)V_single.otpu"; // This is the template path
							Layers = {1, 1};
							Columns = {i+NoofVgs+1+2*NoofVgs, i+NoofVgs+1+3*NoofVgs};
							LineTypes = {1, 1}; // 1 for line plot, 2 for scatter plot
							PlotSingle(graphname$, Template$, TemplateGeneric$, Layers, 2, Columns, LineTypes, previousworkbook$, LegendUpdate);
							
							
							win -a %(previousworkbook$);  // activate the previous window (workbook)
						};
					window -ch 1; // hide the output workbook that was processed
				};
			};
}