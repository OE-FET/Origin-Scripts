// This script is used in transfer curves taken with the testingrig in two drain voltages. It loops over all the workbooks in the folder and plots the transfer and output curves.
// It then calculates and plots the (linear and saturation) mobility, threshold voltage, and reliability factor.
// NOTE: The saturation curve is best measured by short-circuiting the drain and gate and sweeping them simultaneously. This eliminates any chance of minority carriers participating in the mobility calculations.
// Author: Mingfei Xiao
// Version: 3.1
// Current status: Works well.

[Main]
//uncomment following line to define functions using outside of this scope
//@global=1;
	

//-----------------------------------------------------------------------------------------------------------------------------------------------------------

	del -al *;// Delete all the local and session variables
	
//-----------------------------------------------------------------------------------------------------------------------------------------------------------

	doc -ef LB { // loop over all workbooks in folder
		page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
		page.active = 1; // Switch to the first worksheet.
		
		string sheetname$=page.longname$; // Get the name of worksheet
		
		string material$ = sheetname.GetToken(1,"_")$; // Get the string that shows the material

		string additive$ = sheetname.GetToken(2,"_")$; // Get the string that shows the additive

		string dielectric$ = sheetname.GetToken(3,"_")$; // Get the string that shows the dielectric

		string solvent$ = sheetname.GetToken(4,"_")$; // Get the string that shows the solvent content

		string length$ = sheetname.GetToken(5,"_")$; // Get the string that shows the channel length

		string deviceNo$ = sheetname.GetToken(6,"_")$; // Get the string that shows the device number

		string workbooktype$=sheetname.GetToken(7,"_")$; // Get the string "T" or "O", which shows if the curve is a transfer or output curve


		workbooktype$=workbooktype.GetToken(1,".")$; // Remove ".txt" from the workbooktype
		
		
		// Transfer curve parameters
		double W=1000; // Width [um]
		double L=20; // Length [um]
		double d=3; // Thickness of accumulation layer [nm]
		double er=3.6; // Dielectric constant (CYTOP: 2.1, PMMA: 3.6, SiO2: 3.9)
		double e0=8.854E-12; // Vacuum permittivity [F/m]
		double dielectricthickness=300; // Dielectric thickness [nm] (CYTOP: 500, PMMA: 300nm according to Mark's measurements)
		double Ci=e0*er/(dielectricthickness*10^(-9)); // Insulator capacitance per area [F/m^2]

		
		double Vt; // Threshold voltage
		double rlin; // Reliability factor (Linear)
		double rsat; // Reliability factor (Saturation)
		//double jmaxlin; // Max channel current density (Linear)
		//double jmaxsat; // Max channel current density (Saturation)
		//double Pmaxlin; // Max channel power density (Linear)
		//double Pmaxsat; // Max channel power density (Saturation)
		

//-----------------------------------------------------------------------------------------------------------------------------------------------------------
		// Check for NaN columns
		range rb = [%H]1!wcol(2);  // data range of (Is) (Vd=Vdlin) column (col(B))
		range rc = [%H]1!wcol(3);  // data range of (Is) (Vd=Vdsat) column (col(C))
		
		string NaNb$ = Lookup("NaN", rb)$;
		string NaNc$ = Lookup("NaN", rc)$;
		
		if(Nanb$=="NaN" || Nanc$=="NaN" || exist(%H,2)==0) continue; // If object does not exist or if "NaN" is present, then just continue to the next workbook. When LabVIEW measurements are interrupted, they yield NaN values.
			else
			{
						
					string legend$ = "%(material$)"; // Legend
				//-----------------------------------------------------------------------------------------------------------------------------------------------------------
				
				string previousworkbook$=%H; // Get the name of the current window and store it in previousworkbook$
				
				if (workbooktype$ == "ntrans") // if this is an transfer curve then
				{
						wks.ncols=14; // set total column number to 14						
						
						
						// Extract Vdlin and Vdsat
						string Vdlin$=col(D)[L]$;
						Vdlin$=Vdlin.GetToken(2,"=")$; // Take the string on the right of the "=" sign
						Vdlin$=Vdlin.GetToken(1,"V")$; // Take the string on the left of the "V" (units)
						if (Vdlin.Find('.')!=0)
						{
							Vdlin$=Vdlin.GetToken(1,".")$; // Take the string on the left of the "." (this line gets rid of the decimal points)
						};
						
						
						string Vdsat$=col(E)[L]$;
						Vdsat$=Vdsat.GetToken(2,"=")$; // Take the string on the right of the "=" sign
						Vdsat$=Vdsat.GetToken(1,"V")$; // Take the string on the left of the "V" (units)
						if (Vdsat.Find('.')!=0)
						{
							Vdsat$=Vdsat.GetToken(1,".")$; // Take the string on the left of the "." (this line gets rid of the decimal points)
						};
						
						
						// Extract VgStart and VgStop
						string VgStart$=$(col(A)[1]); // VgStart is the value of the first cell of col(A)						
						string VgStop$=$(col(A)[wks.maxrows/2]); // VgStop is the middle cell of col(A) (assuming the gate voltage has a forward and reverse sweep) - wks.maxrows is the total number of (non-empty) rows
						
						
						// Write long name, units, comments, and parameters of columns
						col(H)[L]$ = col(D)[L]$; // Long name
						col(H)[U]$ = col(D)[U]$; // Units
						col(H)[O]$ = "abs(col(D))";
						col(I)[L]$ = col(E)[L]$; // Long name
						col(I)[U]$ = col(E)[U]$; // Units
						col(I)[O]$ = "abs(col(E))";
						col(J)[L]$ = col(F)[L]$; // Long name
						col(J)[U]$ = col(F)[U]$; // Units
						col(J)[O]$ = "abs(col(F))";
						col(K)[L]$ = col(G)[L]$; // Long name
						col(K)[U]$ = col(G)[U]$; // Units
						col(K)[O]$ = "abs(col(G))";
						
						
						
						col(L)[L]$ = "gm (Linear)"; // Long name
						col(L)[U]$ = S; // Units
						differentiate iy:=Col(H) oy:=Col(L) order:=1;
						col(L)[O]$ = "abs(col(L))";
						col(L)[C]$ = "abs(d(Id (Vd=%(Vdlin$)V)/dV)";
						
						col(M)[L]$ = "Mobility (Linear)"; // Long name
						col(M)[U]$ = cm^2/V*s; // Units
						col(M) = 10000*L*col(L)/(W*Ci*abs(%(Vdlin$))); // The multiplication by 10000 is done to get the mobility in cm^2/Vs, instead of m^2/Vs.
						
						
						
						col(N)[L]$ = "SQRT(Id (Vd=%(Vdsat$)V))"; // Long name
						col(N)[U]$ = A^0.5; // Units
						col(N)[O]$ = "sqrt(col(I))";
						
						col(O)[L]$ = "gm (Saturation)"; // Long name
						col(O)[U]$ = S; // Units
						differentiate iy:=Col(N) oy:=Col(O) order:=1;
						col(O)[O]$ = "abs(col(O))";
						col(O)[C]$ = "abs(d(SQRT(Id (Vd=%(Vdsat$)V))/dV)";
						
						col(P)[L]$ = "Mobility (Saturation)"; // Long name
						col(P)[U]$ = cm^2/V*s; // Units
						col(P) = 10000*2*L*col(O)^2/(W*Ci); // The multiplication by 10000 is done to get the mobility in cm^2/Vs, instead of m^2/Vs.						
						
						
						
						col(Q)[L]$ = "Linear fit on SQRT(Id (Vd=%(Vdsat$)V))"; // Long name
						col(Q)[U]$ = A^0.5; // Units
						int lastrow=wks.maxrows/2; // The upper limit of the integration will be equal to the half of the total number of rows. The total number of rows does not include the empty rows (use "maxrows" command instead of "nRows").
						int firstrow=lastrow-round(lastrow/3); // The lower limit of the integration will extend at a certain number of points from the upper limit.
						fitLR iy:=[%H]1!(1,14)[firstrow:lastrow] oy:=col(Q); // Linear fit
						Vt=-fitLR.a/fitLR.b; // To find the threshold voltage, divide the intercept with the slope.
						Vt=round(Vt,1); // Round the threshold voltage
						
						// Linear extrapolation of the linear fit, to find the intercept with the X axis
						range rq=(1,17); // Define XYrange
						col(Q)=rq(col(A)); // Extrapolate for new X axis (col(A))
						
						
						col(R)[L]$ = "Threshold voltage"; // Long name
						col(R)[U]$ = V; // Units
						Col(R)[1]=Vt; // Threshold voltage
						
						
						//-----------------------------------------------------------------------------------------------------------------------------------------------------------
						
						// Reliability factors
						
						// Find the average linear drain current for Vg=0V: Id,lin (Vd=0V)
						col(S)[L]$ = "Row number for Vg=0"; // Long name
						vfind ix:=col(A) value:=0 ox:=Col(S); // Find all indices for which Vg=0
						
						
						
						col(T)[L]$ = "Id,lin (Vg=0V)"; // Long name
						col(T)[U]$ = A; // Units
						col(T)[1]=col(H)[col(S)[1]];
						col(T)[2]=col(H)[col(S)[2]];
						double IdlinVg0=mean(col(T));
						col(T)[3]=IdlinVg0; // The average Id,lin (Vg=0V)
						wcellcolor col(T)[3] color(yellow); // Color the cell with the average value yellow
						
						
						col(U)[L]$ = "Id,sat (Vg=0V)"; // Long name
						col(U)[U]$ = A; // Units
						col(U)[1]=col(I)[col(S)[1]];
						col(U)[2]=col(I)[col(S)[2]];
						double IdsatVg0=mean(col(U));
						col(U)[3]=IdsatVg0; // The average Id,sat (Vg=0V)
						wcellcolor col(U)[3] color(yellow); // Color the cell with the average value yellow
						
						
						// Reliability factor (Linear)
						col(V)[L]$ = "Reliability factor (Linear)"; // Long name
						col(V)[U]$ = %; // Units
						rlin=100*(max(col(H))-IdlinVg0)/max(abs(col(A)))/max(abs(col(L))); // Multiply by 100, since the units are %
						rlin=round(rlin,1);
						
						// Write rlin on the first cell of col(V)
						col(V)[1]=rlin;
						
						// Reliability factor (Saturation)
						col(W)[L]$ = "Reliability factor (Saturation)"; // Long name
						col(W)[U]$ = %; // Units
						rsat=100*((max(col(N))-SQRT(IdsatVg0)))^2/max(abs(col(A)))^2/max(abs(col(O)))^2; // Multiply by 100, since the units are %
						rsat=round(rsat,1);
						
						// Write rsat on the first cell of col(W)
						col(W)[1]=rsat;
						
						
						//-----------------------------------------------------------------------------------------------------------------------------------------------------------
						
						// Current density and power density
						col(X)[L]$ = "Max channel current density (Linear)"; // Long name
						col(X)[U]$ = A/cm^2; // Units
						col(X)[1] = max(col(H))/(W*10^(-4)*d*10^(-7)); // W is in um and d in nm. They are both converted to cm.
						jmaxlin=col(X)[1];
						
						col(Y)[L]$ = "Max channel current density (Saturation)"; // Long name
						col(Y)[U]$ = A/cm^2; // Units
						col(Y)[1] = max(col(I))/(W*10^(-4)*d*10^(-7)); // W is in um and d in nm. They are both converted to cm.
						jmaxsat=col(Y)[1];
						
						col(Z)[L]$ = "Max channel power density (Linear)"; // Long name
						col(Z)[U]$ = W/cm^2; // Units
						col(Z)[1] = max(col(H))*abs(%(Vdlin$))/(W*10^(-4)*L*10^(-4)); // W and L are in um, and are both converted to cm.
						Pmaxlin=col(Z)[1];
						
						col(AA)[L]$ = "Max channel power density (Saturation)"; // Long name
						col(AA)[U]$ = W/cm^2; // Units
						col(AA)[1] = max(col(I))*abs(%(Vdsat$))/(W*10^(-4)*L*10^(-4)); // W and L are in um, and are both converted to cm.
						Pmaxsat=col(AA)[1];
						
						//-----------------------------------------------------------------------------------------------------------------------------------------------------------
						// Max source-drain electric field (Saturation)
						// NOTE: This should be smaller than 3*10^4 V/cm (see: DOI:10.1038/nmat5035)
						
						col(AB)[L]$ = "Max source-drain electric field (Saturation)"; // Long name
						col(AB)[U]$ = V/cm; // Units
						col(AB)[1] = abs(%(Vdsat$))/(L*10^(-4)); // W and L are in um, and are both converted to cm.
						Esd=col(AB)[1];
						
						//-----------------------------------------------------------------------------------------------------------------------------------------------------------
						// Column legends
						
						col(H)[C]$ = legend$;
						col(I)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(J)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(K)[C]$ = col(H)[C]$; // Comment field (graph legend)
						//col(L)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(M)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(N)[C]$ = col(H)[C]$; // Comment field (graph legend)
						//col(O)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(P)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(Q)[C]$ = col(N)[C]$; // Comment field (graph legend)
						col(R)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(S)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(T)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(U)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(V)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(W)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(X)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(Y)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(Z)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(AA)[C]$ = col(H)[C]$; // Comment field (graph legend)
						col(AB)[C]$ = col(H)[C]$; // Comment field (graph legend)
						
						//-----------------------------------------------------------------------------------------------------------------------------------------------------------
						// Plot graphs
						// Set range variables
						range r1 = [%H]1!col(H);  // data range of abs(Id) (Vd=Vdlin) column)
						range r2 = [%H]1!col(I);  // data range of abs(Id) (Vd=Vdsat) column)
						range r3 = [%H]1!col(J);  // data range of abs(Ig) (Vd=Vdlin) column)
						range r4 = [%H]1!col(K);  // data range of abs(Ig) (Vd=Vdsat) column)
						
						range r5 = [%H]1!col(L);  // data range of gm (Linear) column)
						range r6 = [%H]1!col(M);  // data range of Mobility (Linear) column)
						range r7 = [%H]1!col(N);  // data range of SQRT(Id (Vd=Vdsat) /A) column)
						range r8 = [%H]1!col(O);  // data range of gm (Saturation) column)
						range r9 = [%H]1!col(P);  // data range of Mobility (Saturation) column)
						range r10 = [%H]1!col(Q);  // data range of Linear fit on SQRT(Id (Vd=Vdsat) /A) column)
						range r11 = [%H]1!col(R);  // data range of Threshold voltage column)
						range r12 = [%H]1!col(S);  // data range of Row number for Vg=0 column)
						range r13 = [%H]1!col(T);  // data range of Id,lin (Vg=0V) /A column)
						range r14 = [%H]1!col(U);  // data range of Id,sat (Vg=0V) /A column)
						range r15 = [%H]1!col(V);  // data range of Reliability factor (Linear) column)
						range r16 = [%H]1!col(W);  // data range of Reliability factor (Saturation) column)
						
						
						// Plot transfer curves
						string graphname$="%(material$)_%(additive$)_%(dielectric$)_%(solvent$)_%(length$)_%(deviceNo$)_Transfer";
						if(exist(%(uid2name(range2uid(["%(graphname$)"]))$))==0) // if there is no graph for this type of measurement then create a new graph
						{
							
							// Create graph using the generic template
							win -t p "Transfer.otpu"; // create a graph window using a generic template
							
							page.active = 1; // activate Layer 1
							layer.include(r1);  // plot in the active layer
							layer.include(r2);  // plot in the active layer
							
							
							layer -a;  // rescale the layer
							layer -g; // Group the datasets in the layer to auto-color increment
							layer -gu; // Ungroup the datasets in the layer
							page.longname$= graphname$; //this renames the active window (long name)
							page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
							legend; // Update the legend
							
							// Vt plot
							page.active = 2; // activate Layer 2
							layer.include(r7);  // plot in the active layer
							layer.include(r10);  // plot in the active layer							
							
							layer -a;  // rescale the layer
							
							layer.y.from=0; // place the "From" scale of the Y axis from 0, to show clearly the intercept of the linear fit with the X axis
							
							legend; // Update the legend
							plot -c; // refresh the graph to update the labels
							
							
						};
						else
						{
							// create a graph window using template	
							win -a %(uid2name(range2uid(["%(graphname$)"]))$); // activate the graph window
							layer.include(r1);  // plot in the active layer
							layer.include(r2);  // plot in the active layer
							layer -a;  // rescale the layer
							layer -g; // Group the datasets in the layer to auto-color increment
							layer -gu; // Ungroup the datasets in the layer
							legend; // Update the legend
							
							// Vt plot
							page.active = 2; // activate Layer 2
							layer.include(r7);  // plot in the active layer
							layer.include(r10);  // plot in the active layer							
							
							layer -a;  // rescale the layer
							
							layer.y.from=0; // place the "From" scale of the Y axis from 0, to show clearly the intercept of the linear fit with the X axis
							
							legend; // Update the legend
							plot -c; // refresh the graph to update the labels
							
						};
						
						
						
						
						// Plot mobility
						string graphname$="%(material$)_%(additive$)_%(dielectric$)_%(solvent$)_%(length$)_%(deviceNo$)_Mobility";
						if(exist(%(uid2name(range2uid(["%(graphname$)"]))$))==0) // if there is no graph for this type of measurement then create a new graph
						{
							
							// Check if the template exists, otherwise, use a generic one
							win -t p "Mobility.otpu"; // create a graph window using a generic template
							
							//page.active = 1; // activate Layer 1
							layer -i201 r6;  // plot in the active layer as scatter plot
							layer -i201 r9;  // plot in the active layer as scatter plot
							
							layer -a;  // rescale the layer
							//layer -g; // Group the datasets in the layer to auto-color increment
							//layer -gu; // Ungroup the datasets in the layer
							page.longname$= graphname$; //this renames the active window (long name)
							//page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
							//legend; // Update the legend
							
							
						};
						else
						{
							// create a graph window using template	
							win -a %(uid2name(range2uid(["%(graphname$)"]))$); // activate the graph window
							page.active = 1; // activate Layer 1
							layer -i201 r6;  // plot in the active layer as scatter plot
							layer -i201 r9;  // plot in the active layer as scatter plot		
							
							layer -a;  // rescale the layer
							//layer -g; // Group the datasets in the layer to auto-color increment
							//layer -gu; // Ungroup the datasets in the layer
							//legend; // Update the legend
							
							
							
							
						};
						
						
						
						
						
						
						//// Plot linear fit of SQRT(Idsat) and linear extrapolation (for Vt)
						//string graphname$="%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(dayslength$)_Vt-sat_Vd=%(Vdsat$)V";
						//if(exist(%(uid2name(range2uid(["%(graphname$)"]))$))==0) // if there is no graph for this type of measurement then create a new graph
						//{
							//
							//win -t p "Generic_Vt-sat.otpu"; // create a graph window using a generic template
							//
							//page.active = 1; // activate Layer 1
							//layer.include(r7);  // plot in the active layer
							//layer.include(r10);  // plot in the active layer							
							//
							//layer -a;  // rescale the layer
							//
							//layer.y.from=0; // place the "From" scale of the Y axis from 0, to show clearly the intercept of the linear fit with the X axis
							//
							////layer -g; // Group the datasets in the layer to auto-color increment
							//page.longname$= graphname$; //this renames the active window (long name)
							//page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
							////layer -gu; // Ungroup the datasets in the layer
							//legend; // Update the legend
							//
							//if (exist(Text2,16)==16) Text2.text$ = V\-(t) = $(Vt)V;
							//plot -c; // refresh the graph to update the labels
							//
						//};
						//else
						//{
							//// create a graph window using template
							//win -a %(uid2name(range2uid(["%(graphname$)"]))$); // activate the graph window
							//page.active = 1; // activate Layer 1
							//layer.include(r7);  // plot in the active layer
							//layer.include(r10);  // plot in the active layer							
							//
							//layer -a;  // rescale the layer
							//layer.y.from=0; // place the "From" scale of the Y axis from 0, to show clearly the intercept of the linear fit with the X axis
							////layer -g; // Group the datasets in the layer to auto-color increment
							////layer -gu; // Ungroup the datasets in the layer
							//legend; // Update the legend
							//
							//if (exist(Text2,16)==16) Text2.text$ = V\-(t)= $(Vt)V;
							//plot -c; // refresh the graph to update the labels
							//
						//};
						
						
				};
				
				//-----------------------------------------------------------------------------------------------------------------------------------------------------------
				else // if this is an output curve
				{						
						wks.name$=Output; // Change the sheet name to "Output"
						int NoofVgs = (wks.ncols-1)/3; // The number of different Vg voltages is going to be equal to the total No of columns, minus the gate voltage column, divided by 3 (as there are three currents for each Vg: Is, Id, Ig).
						wks.ncols = wks.ncols + NoofVgs*2;  // The number of columns will be equal to the old one plus two new columns for each Vg (one for abs(Id) and one for abs(Ig)).						
						wks.colwidth = 8;// set all col width to 8
						
						
						// Extract VdStart and VdStop
						string VdStart$= $(col(A)[1]); // VdStart is the value of the first cell of col(A)						
						string VdStop$=$(col(A)[wks.maxrows/2]); // VdStop is the middle cell of col(A) (assuming the gate voltage has a forward and reverse sweep) - wks.maxrows is the total number of (non-empty) rows
						
						
						loop(i,1,NoofVgs)
							{
								string previousworkbook$=%H; // Get the name of the previous window
								
								// Extract Vg
								int colNo=i+1; // Start from column 2
								
								string Vg$=wcol(colNo)[L]$;
								Vg$=Vg.GetToken(2,"=")$; // Take the string on the right of the "=" sign
								Vg$=Vg.GetToken(1,"V")$; // Take the string on the left of the "V" (units)
								int Vgint = %(Vg$); // Convert string to integer
								Vg$= $(Vgint); // Convert integer to string (these two lines get rid of the decimal points)
								
							
								// Create a new column for abs(Id)
								wcol(i+NoofVgs+1+2*NoofVgs)[L]$ = col(%(i+NoofVgs+1))[L]$; // First Id column is i+NoofVgs+1. First empty column on the right is i+NoofVgs+1+2*NoofVgs. abs(Id(Vg)) and Id(Vg) will have a distance of 2*NoofVgs (e.g. col(N) will be ans(col(F)) if NoofVgs is 4)
								wcol(i+NoofVgs+1+2*NoofVgs)[U]$ = A; // Units
								wcol(i+NoofVgs+1+2*NoofVgs)[O]$ = "abs(col(%(i+NoofVgs+1)))";
								wcol(i+NoofVgs+1+2*NoofVgs)[C]$ =  "Vg=%(Vg$)V";
								
								
								// Create a new column for abs(Ig)
								wcol(i+NoofVgs+1+3*NoofVgs)[L]$ = col(%(i+2*NoofVgs+1))[L]$; // abs(Ig) column will be NoofVgs further away from abs(Id)
								wcol(i+NoofVgs+1+3*NoofVgs)[U]$ = A; // Units
								wcol(i+NoofVgs+1+3*NoofVgs)[O]$ = "abs(col(%(i+2*NoofVgs+1)))";
								wcol(i+NoofVgs+1+3*NoofVgs)[C]$ =  "Vg=%(Vg$)V";
								
								
								// Plot output curve
								range rId = [%H]1!wcol(i+NoofVgs+1+2*NoofVgs);  // data range of abs(Id) column
								range rIg = [%H]1!wcol(i+NoofVgs+1+3*NoofVgs);  // data range of abs(Ig) column
								
								// Output plot with all the Id
								string graphname$="%(material$)_%(additive$)_%(dielectric$)_%(solvent$)_%(length$)_%(deviceNo$)_Output";
								if(exist(%(uid2name(range2uid(["%(graphname$)"]))$))==0) // if there is no graph for this type of measurement then create a new graph
								{
									
									win -t p "Output.otpu"; // create a graph window using a generic template
									
									page.active = 1; // activate Layer 1
									layer.include(rId);  // plot in the active layer
									
									//layer -a;  // rescale the layer
									layer -g; // Group the datasets in the layer to auto-color increment
									layer -gu; // Ungroup the datasets in the layer
									page.longname$= graphname$; //this renames the active window (long name)
									page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
									//legend; // Update the legend
									
								};
								
								else
								{
									// create a graph window using template	
									win -a %(uid2name(range2uid(["%(graphname$)"]))$); // activate the graph window
									page.active = 1; // activate Layer 1
									layer.include(rId);  // plot in the active layer
									//layer -a;  // rescale the layer
									layer -g; // Group the datasets in the layer to auto-color increment
									layer -gu; // Ungroup the datasets in the layer
									//legend; // Update the legend						
									
								};
								
								win -a %(previousworkbook$);  // activate the previous window (workbook)
							};
				};
			};
}