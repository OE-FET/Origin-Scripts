// This script is used in transfer curves taken with the low noise rig in two drain voltages, in consecutive time points. It loops over all the workbooks in the folder and plots the transfer and output curves.
// NOTE: The saturation curve is best measured by short-circuiting the drain and gate and sweeping them simultaneously. This eliminates any chance of minority carriers participating in the mobility calculations.

// Author: Dimitrios Simatos
// Version: 0.3
// Current status: Works well.
// Changes: Removed storage condition (not the same as v0.1, though).


[Main]
//uncomment following line to define functions using outside of this scope
//@global=1;

//-----------------------------------------------------------------------------------------------------------------------------------------------------------

	del -al *;// Delete all the local and session variables
	
//-----------------------------------------------------------------------------------------------------------------------------------------------------------
function string findConcunits (string concunits)
{
	switch (%(concunits$)) // Case study
		{
			case "gl": // If the string is "gl", write "g/l" in the comment field
				conunitslegend$ = "g/l"; // Comment field (graph legend)
				break;
			
			default: // For all other numbers, use plural form
				conunitslegend$ = "mg/ml"; // Comment field (graph legend)
				break;
		}
			
		return conunitslegend$;
}

function string findAdditive (string additivetype)
{
	switch (%(additivetype$)) // Case study
		{
			case "Pristine": // If the string is "TCNQ", write "TCNQ" in the comment field
				additivegraphlegend$ = "Pristine"; // Comment field (graph legend)
				break;
			
			case "TCNQ": // If the string is "TCNQ", write "TCNQ" in the comment field
				additivegraphlegend$ = "+ TCNQ"; // Comment field (graph legend)
				break;
			
			case "F2TCNQ": // If the string is "F2TCNQ", write "F2TCNQ" in the comment field
				additivegraphlegend$ = "+ F2TCNQ"; // Comment field (graph legend)
				break;
			
			case "F4TCNQ": // If the string is "F4TCNQ", write "F4TCNQ" in the comment field
				additivegraphlegend$ = "+ F4TCNQ"; // Comment field (graph legend)
				break;
			
			case "SAM-1OCT-v": // If the number is 1, use single form
				additivegraphlegend$ = "+ 1-Octanethiol (vapor)"; // Comment field (graph legend)
				break;
			
			case "SAM-1OCT-i": // If the number is 1, use single form
				additivegraphlegend$ = "+ 1-Octanethiol (immersion)"; // Comment field (graph legend)
				break;
			
			case "SAM-TDF1OCT-v": // If the number is 1, use single form
				additivegraphlegend$ = "+ 3,3,4,4,5,5,6,6,7,7,8,8,8-Tridecafluoro-1-octanethiol (vapor)"; // Comment field (graph legend)
				break;
			
			case "SAM-TDF1OCT-i": // If the number is 1, use single form
				additivegraphlegend$ = "+ 3,3,4,4,5,5,6,6,7,7,8,8,8-Tridecafluoro-1-octanethiol (immersion)"; // Comment field (graph legend)
				break;
			
			default: // For all other strings, write "Pristine" in the comment field
				additivegraphlegend$ = "Pristine"; // Comment field (graph legend)
				break;
		}
			
		return additivegraphlegend$;
}

function string findCondition (string condition)
{
	switch (%(condition$)) // Case study
		{
			case "DI-H2O": // If the string is "ultrapure", write "ultrapure water" in the comment field
				condgraphlegend$ = "DI water"; // Comment field (graph legend)
				break;
			
			case "up-H2O": // If the string is "ultrapure", write "ultrapure water" in the comment field
				condgraphlegend$ = "Ultrapure water"; // Comment field (graph legend)
				break;
			
			case "t-H2O": // If the string is "town", write "town water" in the comment field
				condgraphlegend$ = "Town water"; // Comment field (graph legend)
				break;
			
			case "ss": // If the string is "town", write "town water" in the comment field
				condgraphlegend$ = "Saline solution"; // Comment field (graph legend)
				break;
			
			case "pbuffer": // If the string is "phosphatebuffer", write "Phosphate buffer (pH="pHValue", "buffer concentration" "buffer concentration units")" in the comment field
				string pH$ = condition.GetToken(2,"-")$; // get the string, which shows the pH
				pH$ = pH.Substitute(".", ",", 0)$; // Substitute comma with dot
				string bufferconcentration$ = condition.GetToken(3,"-")$; // get the string, which shows the buffer concentration
				string bufferconcunits$ = condition.GetToken(4,"-")$; // get the string, which shows the buffer concentration
				condgraphlegend$ = "Phosphate buffer (pH= %(pH$), %(bufferconcentration$) %(bufferconcunits$)"; // Comment field (graph legend)
				break;
				
			default: // For all other strings, write the condition string in the comment field
				condgraphlegend$ = condition$; // Comment field (graph legend)
				break;
		}
			
		return condgraphlegend$;
}

function string findTime (string timelength)
{
	if (timelength$ != "initial")
		{
			timeNo$ = timelength.GetToken(1,"-")$; // get the string, which shows the time (number)
			timeunits$ = timelength.GetToken(2,"-")$; // get the string, which shows the time units
			
			if (timeunits$ == "min")
				timeunits$ = "minutes";
			
			timegraphlegend$ = timeNo$ + " " + timeunits$; // Comment field (graph legend)
			
			if (timeNo$ == "1")
				timegraphlegend.TrimRight("s"); // If the number is 1, use single form
			
		};
		else
			//timegraphlegend$ = timelength$; // Legend
			timegraphlegend$ = "Initial"; // Legend
			
		return timegraphlegend$;
}

function string findMode (string mode)
{
	switch (%(mode$)) // Case study
		{
			case "P": // If the string is "P", write "Pulsed" in the comment field
				modegraphlegend$ = "Pulsed"; // Comment field (graph legend)
				break;
			
			case "C": // If the string is "C", write "Continuous" in the comment field
				modegraphlegend$ = "Continuous"; // Comment field (graph legend)
				break;
			
			default: // For all other cases, write "Continuous" in the comment field
				modegraphlegend$ = "Continuous"; // Comment field (graph legend)
				break;
		}
			
		return modegraphlegend$;
}

function string findInTime (string intime)
{
	switch (%(intime$)) // Case study
		{
			case "S": // If the string is "S", write "Short" in the comment field
				intimegraphlegend$ = "Short"; // Comment field (graph legend)
				break;
			
			case "M": // If the string is "M", write "Medium" in the comment field
				intimegraphlegend$ = "Medium"; // Comment field (graph legend)
				break;
			
			case "L": // If the string is "L", write "Long" in the comment field
				intimegraphlegend$ = "Long"; // Comment field (graph legend)
				break;
			
			default: // For all other cases, write "Long" in the comment field
				intimegraphlegend$ = "Long"; // Comment field (graph legend)
				break;
		}
			
		return intimegraphlegend$;
}

	// Parameters
	string Rate$="none";
	string CycleLength$="900";
//-----------------------------------------------------------------------------------------------------------------------------------------------------------

	string templatepath$="C:\Users\Administrator\Documents\OriginLab\2018\User Files\Templates\"; // define the template path
	string IdonUavgTimeWorkbook$; // The long name of the Idon-Uavg-Time workbook
	string IdonTimeGraph$; // The long name of the Idon-Time graph
	//string UavgTimeGraph$; // The long name of the Uavg-Time graph
	//string VtTimeGraph$; // The long name of the Vt-Time graph
	
	
	doc -ef LB { // loop over all workbooks in folder
		page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
		page.active = 1; // Switch to the first worksheet.
		
		string sheetname$=page.longname$; // Get the name of worksheet
		
		int i = sheetname.Find("Idon-Time");
		if(i!=0) continue; // If "Idon-Uavg-Time" is present in the filename, then continue.
		
		string batch$ = sheetname.GetToken(1,"_")$; // Get the string that shows the batch
		string architecture$ = sheetname.GetToken(2,"_")$; // Get the string that shows the architecture
		string material$ = sheetname.GetToken(3,"_")$; // Get the string that shows the material

		string concentration$ = sheetname.GetToken(4,"_")$; // Get the string that shows the concentration
		string concnumber$ = concentration.GetToken(1,"-")$; // Get the string that shows the concentration number
		string concunits$ = concentration.GetToken(2,"-")$; // Get the string that shows the concentration units

		string solvent$ = sheetname.GetToken(5,"_")$; // Get the string that shows the solvent content

		string annealing$ = sheetname.GetToken(6,"_")$; // Get the string that shows the additive

		string additive$ = sheetname.GetToken(7,"_")$; // Get the string that shows the additive
		string additivetype$ = additive.GetToken(1,"-")$; // Get the string that shows the additive type
		//string addthickness$ = additive.GetToken(2,"-")$; // Get the string that shows the additive thickness
		//string addthicknessunits$ = additive.GetToken(3,"-")$; // Get the string that shows the additive thickness units
		
		//string dielectric$ = sheetname.GetToken(7,"_")$; // Get the string that shows the dielectric
		//string dielectricconc$ = sheetname.GetToken(8,"_")$; // Get the string that shows the dielectric concentration or ratio

		string sampleNo$ = sheetname.GetToken(8,"_")$; // Get the string that shows the sample number

		//string deviceNo$ = sheetname.GetToken(10,"_")$; // Get the string that shows the device number

		//string length$ = sheetname.GetToken(11,"_")$; // Get the string that shows the channel length
		//string lengthnumber$ = length.GetToken(1,"-")$; // Get the string that shows the length number
		//string lengthunits$ = length.GetToken(2,"-")$; // Get the string that shows the length units
		
		string stepNo$ = sheetname.GetToken(10,"_")$; // Get the string that shows the step number in the cycling process
		string condition$ = sheetname.GetToken(11,"_")$; // Get the string that shows the conditions (air/type of liquid)
		string timelength$ = sheetname.GetToken(12,"_")$; // get the string, which shows the elapsed time
		string minutesNo$ = timelength.GetToken(1,"-")$; // get the string, which shows the number of minutes
		string meastype$=sheetname.GetToken(13,"_")$; // Get the string "T" or "O", which shows if the curve is a transfer or output curve
		string measNo$=sheetname.GetToken(14,"_")$; // Get the string that shows the measurement number
		string mode$=sheetname.GetToken(15,"_")$; // Get the string that shows the measurement mode
		string intime$=sheetname.GetToken(16,"_")$; // Get the string that shows the integration time
		intime$=intime.GetToken(1,".")$; // Remove ".txt" from the integration time
		
		
		//// Transfer curve parameters
		//double W=1000; // Width [um]
		////double L=20; // Length [um]
		//double L=%(lengthnumber$); // Length [um] (extracted from the file name)
		//double d=3; // Thickness of accumulation layer [nm]
		//double er=2.1; // Dielectric constant (CYTOP: 2.1, PMMA: 3.6, SiO2: 3.9)
		//double e0=8.854E-12; // Vacuum permittivity [F/m]
		//double dielectricthickness=550; // Dielectric thickness [nm]
		//double Ci=e0*er/(dielectricthickness*10^(-9)); // Insulator capacitance per area [F/m^2]
		////double Ci=5.2E-5; // Ci for Cytop (Mark: 3.2 nF, 5.2 is for PMMA)
		
		//double jmaxlin; // Max channel current density (Linear)
		//double jmaxsat; // Max channel current density (Saturation)
		//double Pmaxlin; // Max channel power density (Linear)
		//double Pmaxsat; // Max channel power density (Saturation)
		//double Idonlin; // Id on (Linear)
		double Idonsat; // Id on (Saturation)
		//double ulinavg; // Average mobility (Linear)
		//double usatavg; // Average mobility (Saturation)
		//
		//string Vdlin$; // Vd in the linear regime
		//string Vdsat$; // Vd in the saturation regime
		//double Vtlin; // Threshold voltage (Linear)
		//double Vtsat; // Threshold voltage (Saturation)
		//double rlin; // Reliability factor (Linear)
		//double rsat; // Reliability factor (Saturation)
		
		string conunitslegend$; // This string will depend on "concunits" and it will display the concentration for the graph legend
		string additivegraphlegend$; // This string will depend on "additive" and it will display the type of additive for the graph legend
		string condgraphlegend$; // This string will depend on "condition" and it will display the type of condition for the graph legend
		string timegraphlegend$; // This string will depend on "minutesNo" and it will display the number of minutes for the graph legend
		string modegraphlegend$; // This string will depend on "mode" and it will display the measurement mode for the graph legend
		string intimegraphlegend$; // This string will depend on "intime" and it will display the integration time for the graph legend
		

//-----------------------------------------------------------------------------------------------------------------------------------------------------------
		// Check for NaN columns
		range rb = [%H]1!wcol(2);  // data range of (Is) (Vd=Vdlin) column (col(B))
		range rc = [%H]1!wcol(3);  // data range of (Is) (Vd=Vdsat) column (col(C))
		
		string NaNb$ = Lookup("NaN", rb)$;
		string NaNc$ = Lookup("NaN", rc)$;
		
		if(Nanb$=="NaN" || Nanc$=="NaN" || exist(%H,2)==0) continue; // If object does not exist or if "NaN" is present, then just continue to the next workbook. When LabVIEW measurements are interrupted, they yield NaN values.
			else
			{
				//-----------------------------------------------------------------------------------------------------------------------------------------------------------
				// Case structures from filenames (used for legends).
				
				conunitslegend$ = findConcunits(concunits$)$; // Note ending '$'
				additivegraphlegend$ = findAdditive(additive$)$; // Note ending '$'
				condgraphlegend$ = findCondition(condition$)$; // Note ending '$'
				timegraphlegend$ = findTime(timelength$)$; // Note ending '$'
				modegraphlegend$ = findMode(mode$)$; // Note ending '$'
				intimegraphlegend$ = findInTime(intime$)$; // Note ending '$'
				
				
				string legend$ = "%(condgraphlegend$), %(timegraphlegend$), %(modegraphlegend$)"; // Legend
				//-----------------------------------------------------------------------------------------------------------------------------------------------------------
				
				string previousworkbook$=%H; // Get the name of the current window and store it in previousworkbook$
				
				
				if (meastype$ == "T") // if this is an transfer curve then
				{
						wks.name$=Transfer; // Change the sheet name to "Transfer"
						wks.ncols=6; // set total column number to 6
						wks.colwidth = 10;// set all col width to 10
						
						//// Extract Vdlin and Vdsat
						//Vdlin$=col(D)[L]$;
						//Vdlin$=Vdlin.GetToken(2,"=")$; // Take the string on the right of the "=" sign
						//Vdlin$=Vdlin.GetToken(1,"V")$; // Take the string on the left of the "V" (units)
						//if (Vdlin.Find('.')!=0 && Vdlin.GetToken(2,".")$ == "0")
							//Vdlin$=Vdlin.GetToken(1,".")$; // Take the string on the left of the "." (this line gets rid of the decimal points if the right digit is 0)
						
						
						Vdsat$=col(C)[L]$;
						Vdsat$=Vdsat.GetToken(2,"=")$; // Take the string on the right of the "=" sign
						Vdsat$=Vdsat.GetToken(1,"V")$; // Take the string on the left of the "V" (units)
						if (Vdsat.Find('.')!=0 && Vdsat.GetToken(2,".")$ == "0")
							Vdsat$=Vdsat.GetToken(1,".")$; // Take the string on the left of the "." (this line gets rid of the decimal points if the right digit is 0)
						
						
						// Extract VgStart and VgStop
						string VgStart$=$(col(A)[1]); // VgStart is the value of the first cell of col(A)						
						string VgStop$=$(col(A)[wks.maxrows/2]); // VgStop is the middle cell of col(A) (assuming the gate voltage has a forward and reverse sweep) - wks.maxrows is the total number of (non-empty) rows
						
						
						// Extract Idon in the Linear and Saturation regime
						//Idonlin=$(col(D)[wks.maxrows/2]); // Id on (Linear) is the middle cell of col(D) (assuming the gate voltage has a forward and reverse sweep) - wks.maxrows is the total number of (non-empty) rows
						Idonsat=$(col(C)[wks.maxrows/2]); // Id on (Linear) is the middle cell of col(C) (assuming the gate voltage has a forward and reverse sweep) - wks.maxrows is the total number of (non-empty) rows
						
						
						// Write long name, units, comments, and parameters of columns
						col(E)[L]$ = col(C)[L]$; // Long name
						col(E)[U]$ = col(C)[U]$; // Units
						col(E)[O]$ = "abs(col(C))";
						col(F)[L]$ = col(D)[L]$; // Long name
						col(F)[U]$ = col(D)[U]$; // Units
						col(F)[O]$ = "abs(col(D))";
						
						
						
						//col(L)[L]$ = "gm (Linear)"; // Long name
						//col(L)[U]$ = S; // Units
						//differentiate iy:=Col(H) oy:=Col(L) order:=1;
						//col(L)[O]$ = "abs(col(L))";
						//col(L)[C]$ = "abs(d(Id (Vd=%(Vdlin$)V)/dV)";
						//
						//col(M)[L]$ = "Mobility (Linear)"; // Long name
						//col(M)[U]$ = cm^2/V*s; // Units
						//col(M) = 10000*L*col(L)/(W*Ci*abs(%(Vdlin$))); // The multiplication by 10000 is done to get the mobility in cm^2/Vs, instead of m^2/Vs.
						//
						//// The average mobilities are derived by using the linear fit of the slope of the Id (SQRT(Id)) in the Linear (Saturation) regime, instead of the point derivative.
						//
						//col(N)[L]$ = "Linear fit on Id (Vd=%(Vdlin$)V)"; // Long name
						//col(N)[U]$ = A; // Units
						//int lastrowlin=wks.maxrows/2; // The upper limit of the integration will be equal to the half of the total number of rows. The total number of rows does not include the empty rows (use "maxrows" command instead of "nRows").
						//int firstrowlin=lastrowlin-round(lastrowlin/3); // The lower limit of the integration will extend at a certain number of points from the last row.
						//fitLR iy:=[%H]1!(1,8)[firstrowlin:lastrowlin] oy:=col(N); // Linear fit
						//Vtlin = -fitLR.a/fitLR.b; // To find the threshold voltage, divide the intercept with the slope.
						//Vtlin = round(Vtlin,1); // Round the threshold voltage
						//
						//
						//// Linear extrapolation of the linear fit, to find the intercept with the X axis
						//range rn=(1,14); // Define XYrange
						//col(N)=rn(col(A)); // Extrapolate for new X axis (col(A))
						//
						//
						//// The average mobilities are derived by using the linear fit of the slope of the Id (SQRT(Id)) in the Linear (Saturation) regime, instead of the point derivative.
						//col(O)[L]$ = "Average mobility (Linear)"; // Long name
						//col(O)[U]$ = cm^2/V*s; // Units
						//col(O)[1] = 10000*L*abs(fitLR.b)/(W*Ci*abs(%(Vdlin$))); // The multiplication by 10000 is done to get the mobility in cm^2/Vs, instead of m^2/Vs.
						//ulinavg=col(O)[1];
						//
						//col(P)[L]$ = "Threshold voltage (Linear)"; // Long name
						//col(P)[U]$ = V; // Units
						//Col(P)[1]=Vtlin; // Threshold voltage (Linear)
						//
						//
						//
						//col(Q)[L]$ = "SQRT(Id (Vd=%(Vdsat$)V))"; // Long name
						//col(Q)[U]$ = A^(1/2); // Units
						//col(Q)[O]$ = "sqrt(col(I))";
						//
						//col(R)[L]$ = "gm (Saturation)"; // Long name
						//col(R)[U]$ = S; // Units
						//differentiate iy:=Col(Q) oy:=Col(R) order:=1;
						//col(R)[O]$ = "abs(col(R))";
						//col(R)[C]$ = "abs(d(SQRT(Id (Vd=%(Vdsat$)V))/dV)";
						//
						//col(S)[L]$ = "Mobility (Saturation)"; // Long name
						//col(S)[U]$ = cm^2/V*s; // Units
						//col(S) = 10000*2*L*col(R)^2/(W*Ci); // The multiplication by 10000 is done to get the mobility in cm^2/Vs, instead of m^2/Vs.
						//
						//
						//
						//col(T)[L]$ = "Linear fit on SQRT(Id (Vd=%(Vdsat$)V))"; // Long name
						//col(T)[U]$ = A^(1/2); // Units
						//int lastrowsat=wks.maxrows/2; // The upper limit of the integration will be equal to the half of the total number of rows. The total number of rows does not include the empty rows (use "maxrows" command instead of "nRows").
						//int firstrowsat=lastrowsat-round(lastrowsat/3); // The lower limit of the integration will extend at a certain number of points from the last row.
						//fitLR iy:=[%H]1!(1,17)[firstrowsat:lastrowsat] oy:=col(T); // Linear fit
						//Vtsat = -fitLR.a/fitLR.b; // To find the threshold voltage, divide the intercept with the slope.
						//Vtsat = round(Vtsat,1); // Round the threshold voltage
						//
						//// Linear extrapolation of the linear fit, to find the intercept with the X axis
						//range rt=(1,20); // Define XYrange
						//col(T)=rt(col(A)); // Extrapolate for new X axis (col(A))
						//
						//
						//// The average mobilities are derived by using the linear fit of the slope of the Id (SQRT(Id)) in the Linear (Saturation) regime, instead of the point derivative.
						//col(U)[L]$ = "Average mobility (Saturation)"; // Long name
						//col(U)[U]$ = cm^2/V*s; // Units
						//col(U)[1] = 10000*2*L*fitLR.b^2/(W*Ci); // The multiplication by 10000 is done to get the mobility in cm^2/Vs, instead of m^2/Vs.
						//usatavg=col(U)[1];
						//
						//col(V)[L]$ = "Threshold voltage (Saturation)"; // Long name
						//col(V)[U]$ = V; // Units
						//Col(V)[1] = Vtsat; // Threshold voltage (Saturation)
						//
						//
						////-----------------------------------------------------------------------------------------------------------------------------------------------------------
						//
						//// Reliability factors
						//
						//// Find the average linear drain current for Vg=0V: Id,lin (Vd=0V)
						//col(W)[L]$ = "Row number for Vg=0"; // Long name
						//vfind ix:=col(A) value:=0 ox:=Col(W); // Find all indices for which Vg=0
						//
						//
						//
						//col(X)[L]$ = "Id,lin (Vg=0V)"; // Long name
						//col(X)[U]$ = A; // Units
						//col(X)[1]=col(H)[col(W)[1]];
						//col(X)[2]=col(H)[col(W)[2]];
						//double IdlinVg0=mean(col(X));
						//col(X)[3]=IdlinVg0; // The average Id,lin (Vg=0V)
						//wcellcolor col(X)[3] color(yellow); // Color the cell with the average value yellow
						//
						//
						//col(Y)[L]$ = "Id,sat (Vg=0V)"; // Long name
						//col(Y)[U]$ = A; // Units
						//col(Y)[1]=col(I)[col(W)[1]];
						//col(Y)[2]=col(I)[col(W)[2]];
						//double IdsatVg0=mean(col(Y));
						//col(Y)[3]=IdsatVg0; // The average Id,sat (Vg=0V)
						//wcellcolor col(Y)[3] color(yellow); // Color the cell with the average value yellow
						//
						//
						//// Reliability factor (Linear)
						//col(Z)[L]$ = "Reliability factor (Linear)"; // Long name
						//col(Z)[U]$ = %; // Units
						//rlin = 100*(max(col(H))-IdlinVg0)/max(abs(col(A)))/max(abs(col(L))); // Multiply by 100, since the units are %
						//rlin = round(rlin,1);
						//
						//// Write rlin on the first cell of col(Z)
						//col(Z)[1]=rlin;
						//
						//// Reliability factor (Saturation)
						//col(AA)[L]$ = "Reliability factor (Saturation)"; // Long name
						//col(AA)[U]$ = %; // Units
						//rsat = 100*((max(col(Q))-SQRT(IdsatVg0)))^2/max(abs(col(A)))^2/max(abs(col(R)))^2; // Multiply by 100, since the units are %
						//rsat = round(rsat,1);
						//
						//// Write rsat on the first cell of col(W)
						//col(AA)[1]=rsat;
						//
						//
						////-----------------------------------------------------------------------------------------------------------------------------------------------------------
						//
						//// Current density and power density
						//col(AB)[L]$ = "Max channel current density (Linear)"; // Long name
						//col(AB)[U]$ = A/cm^2; // Units
						//col(AB)[1] = max(col(H))/(W*10^(-4)*d*10^(-7)); // W is in um and d in nm. They are both converted to cm.
						//jmaxlin=col(AB)[1];
						//
						//col(AC)[L]$ = "Max channel current density (Saturation)"; // Long name
						//col(AC)[U]$ = A/cm^2; // Units
						//col(AC)[1] = max(col(I))/(W*10^(-4)*d*10^(-7)); // W is in um and d in nm. They are both converted to cm.
						//jmaxsat=col(AC)[1];
						//
						//col(AD)[L]$ = "Max channel power density (Linear)"; // Long name
						//col(AD)[U]$ = W/cm^2; // Units
						//col(AD)[1] = max(col(H))*abs(%(Vdlin$))/(W*10^(-4)*L*10^(-4)); // W and L are in um, and are both converted to cm.
						//Pmaxlin=col(AD)[1];
						//
						//col(AE)[L]$ = "Max channel power density (Saturation)"; // Long name
						//col(AE)[U]$ = W/cm^2; // Units
						//col(AE)[1] = max(col(I))*abs(%(Vdsat$))/(W*10^(-4)*L*10^(-4)); // W and L are in um, and are both converted to cm.
						//Pmaxsat=col(AE)[1];
						//
						////-----------------------------------------------------------------------------------------------------------------------------------------------------------
						//// Max source-drain electric field (Saturation)
						//// NOTE: This should be smaller than 3*10^4 V/cm (DOI: 10.1038/nmat5035)
						//
						//col(AF)[L]$ = "Max source-drain electric field (Saturation)"; // Long name
						//col(AF)[U]$ = V/cm; // Units
						//col(AF)[1] = abs(%(Vdsat$))/(L*10^(-4)); // W and L are in um, and are both converted to cm.
						//Esd=col(AF)[1];
						//
						////-----------------------------------------------------------------------------------------------------------------------------------------------------------
						//
						//// Contact resistance (Riccardo di Pietro's model, DOI: 10.1063/1.4876057)
						//
						//col(AG)[L]$ = "Average linear current"; // Long name
						//col(AG)[U]$ = A; // Units
						//col(AG)[O]$ = "abs(col(B)-col(D))/2";
						//
						//col(AH)[L]$ = "Error"; // Long name
						//col(AH)[U]$ = A; // Units
						//col(AH)[O]$ = "col(F)/2 + col(AG)*0.01";
						//
						//col(AI)[L]$ = "Average saturation current"; // Long name
						//col(AI)[U]$ = A; // Units
						//col(AI)[O]$ = "abs(col(C)-col(E))/2";
						//
						//col(AJ)[L]$ = "Error"; // Long name
						//col(AJ)[U]$ = A; // Units
						//col(AJ)[O]$ = "col(G)/2 + col(AI)*0.01";
						//
						////col(AG)[L]$ = "d(Id (Vd=%(Vdsat$)V)/dV"; // Long name
						////col(AG)[U]$ = S; // Units
						////differentiate iy:=Col(AE) oy:=Col(AG) order:=1;
						//
						//col(AK)[L]$ = "d(Id (Vd=%(Vdsat$)V)/dV"; // Long name
						//col(AK)[U]$ = S; // Units
						//differentiate iy:=Col(I) oy:=Col(AK) order:=1;
						//
						//col(AL)[L]$ = "Rc"; // Long name
						//col(AL)[U]$ = Ohm; // Units
						//col(AL)[O]$ = "abs(%(Vdlin$)/col(AG) - 1/col(AK))";
						//
						////col(AL)[L]$ = "Contact resistance"; // Long name
						////col(AL)[U]$ = Ohm; // Units
						////col(AL)[O]$ = "abs(%(Vdlin$)/col(H) - 1/col(AK))";
						//
						//col(AM)[L]$ = "Error"; // Long name
						//col(AM)[U]$ = A; // Units
						//col(AM)[O]$ = "col(AL)*2*sqrt((col(AJ)/col(AI))^2+(col(AH)/col(AG))^2)";
						//
						//col(AN)[L]$ = "Channel voltage"; // Long name
						//col(AN)[U]$ = V; // Units
						//col(AN)[O]$ = "col(AG)/col(AK)";
						//
						////col(AN)[L]$ = "Channel voltage"; // Long name
						////col(AN)[U]$ = V; // Units
						////col(AN)[O]$ = "col(H)/col(AK)";
						//
						//col(AO)[L]$ = "Error"; // Long name
						//col(AO)[U]$ = A; // Units
						//col(AO)[O]$ = "col(AN)*2*sqrt((col(AJ)/col(AI))^2+(col(AH)/col(AG))^2)";
						
						
						//-----------------------------------------------------------------------------------------------------------------------------------------------------------
						// Column legends
						
						col(E)[C]$ = legend$;
						col(F)[C]$ = col(E)[C]$ + ", Leakage"; // Comment field (graph legend)
						
						//-----------------------------------------------------------------------------------------------------------------------------------------------------------
						// Plot graphs
						// Set range variables
						
						range rIdsat = [%H]1!col(E);  // data range of abs(Id) column (col(E))
						range rIgsat = [%H]1!col(F);  // data range of abs(Ig) column (col(F))
						
						//range rIdlin = [%H]1!col(H);  // data range of abs(Id) (Vd=Vdlin) column
						//range rIdsat = [%H]1!col(I);  // data range of abs(Id) (Vd=Vdsat) column
						//range rIglin = [%H]1!col(J);  // data range of abs(Ig) (Vd=Vdlin) column
						//range rIgsat = [%H]1!col(K);  // data range of abs(Ig) (Vd=Vdsat) column
						//
						//range rgmlin = [%H]1!col(L);  // data range of gm (Linear) column
						//range rulin = [%H]1!col(M);  // data range of Mobility (Linear) column
						//range rIdlinLF = [%H]1!col(N);  // data range of Linear fit on SQRT(Id (Vd=Vdsat) /A) column
						//range rSqrtIdsat = [%H]1!col(Q);  // data range of SQRT(Id (Vd=Vdsat) /A) column
						//range rgmsat = [%H]1!col(R);  // data range of gm (Saturation) column
						//range rusat = [%H]1!col(S);  // data range of Mobility (Saturation) column
						//range rSqrtIdsatLF = [%H]1!col(T);  // data range of Linear fit on SQRT(Id (Vd=Vdsat) /A) column
						//range rRc = [%H]1!col(AL);  // data range of Contact resistance (Linear) column
						
						
						
						//// Plot linear transfer curves for a single time point
						//string graphname$="%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_Transfer_Vd=%(Vdlin$)V";
						//if(exist(%(uid2name(range2uid(["%(graphname$)"]))$))==0) // if there is no graph for this type of measurement then create a new graph
						//{
							//// Check if the template exists, otherwise, use a generic one
							//string Template$="%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_Transfer_Leakage_Vd=%(Vdlin$)V_Vg=%(VgStart$)V to %(VgStop$)V_single.otpu"; // This is the template path
							//if (exist(Template$)!=-1)// if the template exists
								//win -t p "%(Template$)"; // create a graph window using template
							//else
								//win -t p "%(templatepath$)Generic_Transfer_single.otpu"; // create a graph window using a generic template
							//
							//page.longname$ = graphname$; //this renames the active window (long name)
							//page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
						//};
						//else
							//win -a %(uid2name(range2uid(["%(graphname$)"]))$); // activate the graph window
							//
						//page.active = 1; // activate Layer 1
						//layer.include(rIdlin);  // plot in the active layer
						//layer.include(rIglin);  // plot in the active layer
						//
						////layer -a;  // rescale the layer
						////layer -g; // Group the datasets in the layer to auto-color increment
						////layer -gu; // Ungroup the datasets in the layer
						//legend; // Update the legend
						
						
						// Plot saturation transfer curves for a single time point
						string graphname$="%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(sampleNo$)_step_%(stepNo$)_%(condition$)_%(timelength$)_Transfer_Leakage_Vd=%(Vdsat$)V";
						if(exist(%(uid2name(range2uid(["%(graphname$)"]))$))==0) // if there is no graph for this type of measurement then create a new graph
						{
							// Check if the template exists, otherwise, use a generic one
							string Template$="%(templatepath$)Stab_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_rate_%(Rate$)_Transfer_Leakage_Vd=%(Vdsat$)V_Vg=%(VgStart$)V to %(VgStop$)V_single.otpu"; // This is the template path
							if (exist(Template$)!=-1)// if the template exists
								win -t p "%(Template$)"; // create a graph window using template
							else
								win -t p "%(templatepath$)Generic_Transfer_single.otpu"; // create a graph window using a generic template
							
							page.longname$ = graphname$; //this renames the active window (long name)
							page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
						};
						else
							win -a %(uid2name(range2uid(["%(graphname$)"]))$); // activate the graph window
							
						page.active = 1; // activate Layer 1
						layer.include(rIdsat);  // plot in the active layer
						layer.include(rIgsat);  // plot in the active layer
						
						//layer -a;  // rescale the layer
						//layer -g; // Group the datasets in the layer to auto-color increment
						//layer -gu; // Ungroup the datasets in the layer
						legend; // Update the legend
						
						
						// Check if the measurement is the last measurement at a specific time point
						string nextmeassheetname$="%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(sampleNo$)_step_%(stepNo$)_%(condition$)_%(timelength$)_%(meastype$)_$(%(measNo$)+1)_%(mode$)_%(intime$).txt";
						if(exist(%(uid2name(range2uid(["%(nextmeassheetname$)"]))$))!=0)
							continue; // if this is not the last measurement of its kind, then continue to the next iteration
						
						
						//// Plot joint transfer curve - SQRT(Idsat) graph for a single time point
						//string graphname$="%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(timelength$)_Transfer_Vd=%(Vdlin$),%(Vdsat$)V_Vt-sat_Vd=%(Vdsat$)V";
						//if(exist(%(uid2name(range2uid(["%(graphname$)"]))$))==0) // if there is no graph for this type of measurement then create a new graph
						//{
							//// Check if the template exists, otherwise, use a generic one
							//string Template$="%(templatepath$)Stab_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_Transfer_Vd=%(Vdlin$),%(Vdsat$)V_Vt-sat_Vd=%(Vdsat$)V_Vg=%(VgStart$)V to %(VgStop$)V_single.otpu"; // This is the template path
							//if (exist(Template$)!=-1)// if the template exists
								//win -t p "%(Template$)"; // create a graph window using template
							//else
								//win -t p "%(templatepath$)Generic_Transfer_Vt-sat.otpu"; // create a graph window using a generic template
							//
							//page.longname$ = graphname$; //this renames the active window (long name)
							//page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
						//};
						//else
							//win -a %(uid2name(range2uid(["%(graphname$)"]))$); // activate the graph window
							//
						//page.active = 1; // activate Layer 1
						//layer.include(rIdlin);  // plot in the active layer
						//layer.include(rIdsat);  // plot in the active layer
						//
						//if (exist(Text3,16)==16) Text3.text$ = (V\-(d) = %(Vdlin$)V);
						//if (exist(Text4,16)==16) Text4.text$ = (V\-(d) = %(Vdsat$)V);
						//if (exist(Text5,16)==16) Text5.text$ = at V\-(d) = %(Vdsat$)V;
						//if (exist(Text,16)==16) Text.text$ = V\-(t,sat) = $(Vtsat)V; //(NOTE: The "Vt" label of the template is assumed to be on Layer 1.)
						//plot -c; // refresh the graph to update the labels
						//
						////layer -a;  // rescale the layer
						////layer -g; // Group the datasets in the layer to auto-color increment
						////layer -gu; // Ungroup the datasets in the layer
						////legend; // Update the legend
						//
						//page.active = 2; // activate Layer 2
						//layer.include(rSqrtIdsat);  // plot in the active layer
						//layer.include(rSqrtIdsatLF);  // plot in the active layer
						//layer.y.from=0; // place the "From" scale of the Y axis from 0, to show clearly the intercept of the linear fit with the X axis
						
						
						
						//// Plot linear transfer curve for all time points
						//string graphname$="%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_Transfer_Vd=%(Vdlin$)V";
						//if(exist(%(uid2name(range2uid(["%(graphname$)"]))$))==0) // if there is no graph for this type of measurement then create a new graph
						//{
							//// Check if the template exists, otherwise, use a generic one
							//string Template$="%(templatepath$)Stab_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_Transfer_Leakage_Vd=%(Vdlin$)V_Vg=%(VgStart$)V to %(VgStop$)V.otpu"; // This is the template path
							//if (exist(Template$)!=-1)// if the template exists
								//win -t p "%(Template$)"; // create a graph window using template
							//else
								//win -t p "%(templatepath$)Generic_Transfer_single.otpu"; // create a graph window using a generic template
							//
							//page.longname$ = graphname$; //this renames the active window (long name)
							//page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
						//};
						//else
							//win -a %(uid2name(range2uid(["%(graphname$)"]))$); // activate the graph window
							//
						//page.active = 1; // activate Layer 1
						//layer.include(rIdlin);  // plot in the active layer
						//layer.include(rIglin);  // plot in the active layer
						//
						////layer -a;  // rescale the layer
						////layer -g; // Group the datasets in the layer to auto-color increment
						////layer -gu; // Ungroup the datasets in the layer
						////legend; // Update the legend
						
						
						// Plot saturation transfer curve for all time points
						string graphname$="%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(sampleNo$)_step_%(stepNo$)_%(condition$)_Transfer_Leakage_Vd=%(Vdsat$)V";
						if(exist(%(uid2name(range2uid(["%(graphname$)"]))$))==0) // if there is no graph for this type of measurement then create a new graph
						{
							// Check if the template exists, otherwise, use a generic one
							string Template$="%(templatepath$)Stab_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_rate_%(Rate$)_Transfer_Leakage_Vd=%(Vdsat$)V_Vg=%(VgStart$)V to %(VgStop$)V.otpu"; // This is the template path
							if (exist(Template$)!=-1)// if the template exists
								win -t p "%(Template$)"; // create a graph window using template
							else
								win -t p "%(templatepath$)Generic_Transfer_single.otpu"; // create a graph window using a generic template
							
							page.longname$ = graphname$; //this renames the active window (long name)
							page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
						};
						else
							win -a %(uid2name(range2uid(["%(graphname$)"]))$); // activate the graph window
							
						page.active = 1; // activate Layer 1
						layer.include(rIdsat);  // plot in the active layer
						layer.include(rIgsat);  // plot in the active layer
						
						//layer -a;  // rescale the layer
						//layer -g; // Group the datasets in the layer to auto-color increment
						//layer -gu; // Ungroup the datasets in the layer
						//legend; // Update the legend
						
						
						// Copy Idon, mobility (Linear and Saturation) and Vt values for all time points
						//IdonUavgTimeWorkbook$="%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_Idon-Uavg-Time_Vd=%(Vdlin$),%(Vdsat$)V.txt";
						IdonUavgTimeWorkbook$="%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(sampleNo$)_step_%(stepNo$)_%(condition$)_Idon-Time_Vd=%(Vdsat$)V.txt";
						if(exist(%(uid2name(range2uid(["%(IdonUavgTimeWorkbook$)"]))$))==0) // if there is no workbook for this type of measurement then create a new workbook
						{
							
							newbook option:=lsname;
							page.longname$ = IdonUavgTimeWorkbook$;
							wks.name$ = "Parameters vs Time"; // Change the sheet name to "Parameters vs Time"
							wks.ncols = 2; // set total column number to 7
							wks.colwidth = 10;// set all col width to 10
							
							col(A)[L]$ = "Time"; // Long name
							col(A)[U]$ = "Minutes"; // Units
							
							//col(B)[L]$ = "Id on"; // Long name
							//col(B)[U]$ = A; // Units
							//col(B)[C]$ = "Linear";							
							
							col(B)[L]$ = "Id on"; // Long name
							col(B)[U]$ = A; // Units
							col(B)[C]$ = "Saturation";
							
							//col(D)[L]$ = "Average mobility"; // Long name
							//col(D)[U]$ = cm^2/V*s; // Units
							//col(D)[C]$ = "Linear";
							//
							//col(E)[L]$ = "Average mobility"; // Long name
							//col(E)[U]$ = cm^2/V*s; // Units
							//col(E)[C]$ = "Saturation";
							//
							//col(F)[L]$ = "Threshold voltage"; // Long name
							//col(F)[U]$ = V; // Units
							//col(F)[C]$ = "Linear";
							//
							//col(G)[L]$ = "Threshold voltage"; // Long name
							//col(G)[U]$ = V; // Units
							//col(G)[C]$ = "Saturation";
							
							window -ch 1; // hide the workbook that was processed
							
							
							// Create plot Idon vs Time
							
							// Check if the template exists, otherwise, use a generic one
							string Template$="%(templatepath$)Stab_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_Idon-Time_Vd=%(Vdsat$)V_Vg=%(VgStart$)V to %(VgStop$)V.otpu"; // This is the template path
							if (exist(Template$)!=-1)// if the template exists
								win -t p "%(Template$)"; // create a graph window using template
							else
								win -t p "%(templatepath$)Generic_Idon-Time.otpu"; // create a graph window using a generic template
							
							page.longname$= "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(sampleNo$)_step_%(stepNo$)_%(condition$)_Idon-Time_Vd=%(Vdsat$)V"; //this renames the active window (long name)
							IdonTimeGraph$ = page.longname$;
							page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
							
							
							//// Create plot u vs Time
							//
							//// Check if the template exists, otherwise, use a generic one
							//string Template$="%(templatepath$)Stab_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_Uavg-Time_Vd=%(Vdlin$),%(Vdsat$)V_Vg=%(VgStart$)V to %(VgStop$)V.otpu"; // This is the template path
							//if (exist(Template$)!=-1)// if the template exists
								//win -t p "%(Template$)"; // create a graph window using template
							//else
								//win -t p "%(templatepath$)Generic_Uavg-Time.otpu"; // create a graph window using a generic template
							//
							//page.longname$= "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_Uavg-Time_Vd=%(Vdlin$),%(Vdsat$)V"; //this renames the active window (long name)
							//UavgTimeGraph$ = page.longname$;
							//page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
							//
							//
							//// Create plot Vt vs Time
							//
							//// Check if the template exists, otherwise, use a generic one
							//string Template$="%(templatepath$)Stab_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_Vt-Time_Vd=%(Vdlin$),%(Vdsat$)V_Vg=%(VgStart$)V to %(VgStop$)V.otpu"; // This is the template path
							//if (exist(Template$)!=-1)// if the template exists
								//win -t p "%(Template$)"; // create a graph window using template
							//else
								//win -t p "%(templatepath$)Generic_Vt-Time.otpu"; // create a graph window using a generic template
							//
							//page.longname$= "%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_Vt-Time_Vd=%(Vdlin$),%(Vdsat$)V"; //this renames the active window (long name)
							//VtTimeGraph$ = page.longname$;
							//page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
							
						};
						
						win -a %(uid2name(range2uid(["%(IdonUavgTimeWorkbook$)"]))$); // activate the workbook
						
						
						// Copy average mobility (Linear and Saturation)
						if (minutesNo$ != "Initial"){ // If minutesNo$ is "Initial" then do not attempt to write the cell.
							col(A)[wks.maxrows+1] = %(minutesNo$); // Increase No of rows by 1.
							//col(B)[wks.maxrows] = Idonlin; // Rows have already increased, so there's no need to add 1.
							col(B)[wks.maxrows] = Idonsat; // Rows have already increased, so there's no need to add 1.
							//col(D)[wks.maxrows] = ulinavg; // Rows have already increased, so there's no need to add 1.
							//col(E)[wks.maxrows] = usatavg; // Rows have already increased, so there's no need to add 1.
							//col(F)[wks.maxrows] = Vtlin; // Rows have already increased, so there's no need to add 1.
							//col(G)[wks.maxrows] = Vtsat; // Rows have already increased, so there's no need to add 1.
						};
						
						win -a %(previousworkbook$);  // activate the previous window (workbook)
						window -ch 1; // hide the workbook that was processed
						continue;
						
				};
				
				//-----------------------------------------------------------------------------------------------------------------------------------------------------------
				else // if this is an output curve
				{						
					wks.name$=Output; // Change the sheet name to "Output"
					int NoofVgs = (wks.ncols-1)/3; // The number of different Vg voltages is going to be equal to the total No of columns, minus the gate voltage column, divided by 3 (as there are three currents for each Vg: Is, Id, Ig).
					wks.ncols = wks.ncols + NoofVgs*2;  // The number of columns will be equal to the old one plus two new columns for each Vg (one for abs(Id) and one for abs(Ig)).						
					wks.colwidth = 8;// set all col width to 8
					
					
					// Extract VdStart and VdStop
					string VdStart$= $(col(A)[1]); // VdStart is the value of the first cell of col(A)						
					string VdStop$=$(col(A)[wks.maxrows/2]); // VdStop is the middle cell of col(A) (assuming the gate voltage has a forward and reverse sweep) - wks.maxrows is the total number of (non-empty) rows
					
					
					loop(i,1,NoofVgs)
						{
							string previousworkbook$=%H; // Get the name of the previous window
							
							// Extract Vg							
							string Vg$=wcol(i+1)[L]$; // Start from column 2
							Vg$=Vg.GetToken(2,"=")$; // Take the string on the right of the "=" sign
							Vg$=Vg.GetToken(1,"V")$; // Take the string on the left of the "V" (units)
							if (Vg.Find('.')!=0 && Vg.GetToken(2,".")$ == "0")
								Vg$=Vg.GetToken(1,".")$; // Take the string on the left of the "." (this line gets rid of the decimal points if the right digit is 0)
							
							
							// Create a new column for abs(Id)
							wcol(i+NoofVgs+1+2*NoofVgs)[L]$ = col(%(i+NoofVgs+1))[L]$; // First Id column is i+NoofVgs+1. First empty column on the right is i+NoofVgs+1+2*NoofVgs. abs(Id(Vg)) and Id(Vg) will have a distance of 2*NoofVgs (e.g. col(N) will be ans(col(F)) if NoofVgs is 4)
							wcol(i+NoofVgs+1+2*NoofVgs)[U]$ = A; // Units
							wcol(i+NoofVgs+1+2*NoofVgs)[O]$ = "abs(col(%(i+NoofVgs+1)))";
							wcol(i+NoofVgs+1+2*NoofVgs)[C]$ =  "%(legend$), Vg=%(Vg$)V";
							
							
							// Create a new column for abs(Ig)
							wcol(i+NoofVgs+1+3*NoofVgs)[L]$ = col(%(i+2*NoofVgs+1))[L]$; // abs(Ig) column will be NoofVgs further away from abs(Id)
							wcol(i+NoofVgs+1+3*NoofVgs)[U]$ = A; // Units
							wcol(i+NoofVgs+1+3*NoofVgs)[O]$ = "abs(col(%(i+2*NoofVgs+1)))";
							wcol(i+NoofVgs+1+3*NoofVgs)[C]$ =  "%(legend$), Vg=%(Vg$)V, Leakage";
							
							
							// Plot output curve
							range rId = [%H]1!wcol(i+NoofVgs+1+2*NoofVgs);  // data range of abs(Id) column
							range rIg = [%H]1!wcol(i+NoofVgs+1+3*NoofVgs);  // data range of abs(Ig) column
							
							
							// Check if the measurement is the last measurement at this specific time point
							string nextmeassheetname$="%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(sampleNo$)_step_%(stepNo$)_%(condition$)_%(timelength$)_%(meastype$)_$(%(measNo$)+1)_%(mode$)_%(intime$).txt";
							if(exist(%(uid2name(range2uid(["%(nextmeassheetname$)"]))$))!=0)
								continue; // if this is not the last measurement of its kind, then continue to the next iteration
							
							
							// Output plot with all the Id for a single time point
							string graphname$="%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(sampleNo$)_step_%(stepNo$)_%(condition$)_%(timelength$)_Output";
							if(exist(%(uid2name(range2uid(["%(graphname$)"]))$))==0) // if there is no graph for this type of measurement then create a new graph
							{
								// Check if the template exists, otherwise, use a generic one
								string Template$="%(templatepath$)Stab_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_rate_%(Rate$)_Output_Vd=%(VdStart$)V to %(VdStop$)V_single.otpu"; // This is the template path
								if (exist(Template$)!=-1)// if the template exists
									win -t p "%(Template$)"; // create a graph window using template
								else
									win -t p "%(templatepath$)Generic_Output.otpu"; // create a graph window using a generic template
								
								page.longname$ = graphname$; //this renames the active window (long name)
								page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
							};
							else
								win -a %(uid2name(range2uid(["%(graphname$)"]))$); // activate the graph window
								
							page.active = 1; // activate Layer 1
							layer.include(rId);  // plot in the active layer
							//layer -a;  // rescale the layer
							//layer -g; // Group the datasets in the layer to auto-color increment
							//layer -gu; // Ungroup the datasets in the layer
							//legend; // Update the legend
							
							
							// Individual output plot with a single Id and Ig for all time points
							string graphname$="%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(sampleNo$)_step_%(stepNo$)_%(condition$)_Output_Vg=%(Vg$)V";
							if(exist(%(uid2name(range2uid(["%(graphname$)"]))$))==0) // if there is no graph for this type of measurement then create a new graph
							{
								// Check if the template exists, otherwise, use a generic one
								string Template$="%(templatepath$)Stab_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_rate_%(Rate$)_Output_Leakage_Vg=%(Vg$)V_Vd=%(VdStart$)V to %(VdStop$)V.otpu"; // This is the template path
								if (exist(Template$)!=-1)// if the template exists
									win -t p "%(Template$)"; // create a graph window using template
								else
									win -t p "%(templatepath$)Generic_Output_single.otpu"; // create a graph window using a generic template
								
								page.longname$ = graphname$; //this renames the active window (long name)
								page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
							};
							else
								win -a %(uid2name(range2uid(["%(graphname$)"]))$); // activate the graph window
								
							page.active = 1; // activate Layer 1
							layer.include(rId);  // plot in the active layer
							layer.include(rIg);  // plot in the active layer
							//layer -a;  // rescale the layer
							//layer -g; // Group the datasets in the layer to auto-color increment
							//layer -gu; // Ungroup the datasets in the layer
							//legend; // Update the legend
							
							win -a %(previousworkbook$);  // activate the previous window (workbook)
						};
					window -ch 1; // hide the output workbook that was processed
				};
				
			};
	};
	
	// Plot Idon, u, and Vt vs Time
	win -a %(uid2name(range2uid(["%(IdonUavgTimeWorkbook$)"]))$); // activate the workbook
	//range rIdonlinTime = [%H]1!col(B);  // data range of Id on (Linear) column
	range rIdonsatTime = [%H]1!col(B);  // data range of Id on (Saturation) column
	//range rulinavgTime = [%H]1!col(D);  // data range of average Mobility (Linear)
	//range rusatavgTime = [%H]1!col(E);  // data range of average Mobility (Saturation)
	//range rVtlinTime = [%H]1!col(F);  // data range of Threshold voltage (Linear) column
	//range rVtsatTime = [%H]1!col(G);  // data range of Threshold voltage (Saturation) column
	
	window -ch 1; // hide the workbook that was processed
	
	win -a %(uid2name(range2uid(["%(IdonTimeGraph$)"]))$); // activate the workbook
	page.active = 1; // activate Layer 1
	
	//layer -i201 rIdonlinTime;  // plot in the active layer as scatter plot
	layer -i201 rIdonsatTime;  // plot in the active layer as scatter plot
};