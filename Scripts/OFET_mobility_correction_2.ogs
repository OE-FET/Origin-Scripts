// This script is used in transfer curves taken with the low noise rig in two drain voltages. It applies the mobility correction factor (Riccardo di Pietro's model, DOI: 10.1063/1.4876057).
// The reason that this exists in a separate script file is Labtalk's programming limits.

// How to use:
// 1. First run the OFET mobility analysis script.
// 2. Run this script.
// 3. Check that the power law linear fitting is correct. Otherwise adjust the "int firstrowsatPL=lastrowsat-round(lastrowsat/3)" row. Reduce the denominator (e.g. to 3) to get a linear fit with more points if needed. Then re-run the script.

// Author: Dimitrios Simatos
// Version: 0.2
// Current status: Works well.
// Changes: Changed the condition for the decimal point truncation.

[Main]
//uncomment following line to define functions using outside of this scope
//@global=1;

//-----------------------------------------------------------------------------------------------------------------------------------------------------------

	del -al *;// Delete all the local and session variables
	
//-----------------------------------------------------------------------------------------------------------------------------------------------------------

	string templatepath$="C:\Users\Administrator\Documents\OriginLab\2018\User Files\Templates\"; // define the template path

	doc -ef LB { // loop over all workbooks in folder
		page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
		page.active = 1; // Switch to the first worksheet.
		
		string sheetname$=page.longname$; // Get the name of worksheet
		
		string batch$ = sheetname.GetToken(1,"_")$; // Get the string that shows the batch
		string architecture$ = sheetname.GetToken(2,"_")$; // Get the string that shows the architecture
		string material$ = sheetname.GetToken(3,"_")$; // Get the string that shows the material

		string concentration$ = sheetname.GetToken(4,"_")$; // Get the string that shows the concentration
		string concnumber$ = concentration.GetToken(1,"-")$; // Get the string that shows the concentration number
		string concunits$ = concentration.GetToken(2,"-")$; // Get the string that shows the concentration units

		string solvent$ = sheetname.GetToken(5,"_")$; // Get the string that shows the solvent content

		string annealing$ = sheetname.GetToken(6,"_")$; // Get the string that shows the additive

		string additive$ = sheetname.GetToken(7,"_")$; // Get the string that shows the additive
		string additivetype$ = additive.GetToken(1,"-")$; // Get the string that shows the additive type
		//string addthickness$ = additive.GetToken(2,"-")$; // Get the string that shows the additive thickness
		//string addthicknessunits$ = additive.GetToken(3,"-")$; // Get the string that shows the additive thickness units
		
		string dielectric$ = sheetname.GetToken(8,"_")$; // Get the string that shows the dielectric
		string dielectricconc$ = sheetname.GetToken(9,"_")$; // Get the string that shows the dielectric concentration or ratio

		string sampleNo$ = sheetname.GetToken(10,"_")$; // Get the string that shows the sample number

		string deviceNo$ = sheetname.GetToken(11,"_")$; // Get the string that shows the device number

		string length$ = sheetname.GetToken(12,"_")$; // Get the string that shows the channel length
		string lengthnumber$ = length.GetToken(1,"-")$; // Get the string that shows the length number
		string lengthunits$ = length.GetToken(2,"-")$; // Get the string that shows the length units

		//string stepNo$ = sheetname.GetToken(8,"_")$; // Get the string that shows the step number in the cycling process
		string condition$ = sheetname.GetToken(13,"_")$; // Get the string that shows the conditions (air/type of liquid)
		string dayslength$ = sheetname.GetToken(14,"_")$; // get the string, which shows the number of days
		string daysNo$ = dayslength.GetToken(1,"-")$; // get the string, which shows the number of days
		//string minutesNo$ = sheetname.GetToken(12,"_")$; // get the string, which shows the number of minutes
		string meastype$=sheetname.GetToken(15,"_")$; // Get the string "T" or "O", which shows if the curve is a transfer or output curve
		string measNo$=sheetname.GetToken(16,"_")$; // Get the string that shows the measurement number
		string mode$=sheetname.GetToken(17,"_")$; // Get the string that shows the measurement mode
		string intime$=sheetname.GetToken(18,"_")$; // Get the string that shows the integration time
		intime$=intime.GetToken(1,".")$; // Remove ".txt" from the integration time
		
		
		// Transfer curve parameters
		double beta; // Parameter for power law dependence of the mobility
		double kappa; // The correction factor for the mobility
		
		double jmaxlin; // Max channel current density (Linear)
		double jmaxsat; // Max channel current density (Saturation)
		double Pmaxlin; // Max channel power density (Linear)
		double Pmaxsat; // Max channel power density (Saturation)
		
		string Vdlin$; // Vd in the linear regime
		string Vdsat$; // Vd in the saturation regime
		double Vtlin; // Threshold voltage (Linear)
		double Vtsat; // Threshold voltage (Saturation)
		double rlin; // Reliability factor (Linear)
		double rsat; // Reliability factor (Saturation)

//-----------------------------------------------------------------------------------------------------------------------------------------------------------
		// Check for NaN columns
		range rb = [%H]1!wcol(2);  // data range of (Is) (Vd=Vdlin) column (col(B))
		range rc = [%H]1!wcol(3);  // data range of (Is) (Vd=Vdsat) column (col(C))
		
		string NaNb$ = Lookup("NaN", rb)$;
		string NaNc$ = Lookup("NaN", rc)$;
		
		if(Nanb$=="NaN" || Nanc$=="NaN" || exist(%H,2)==0) continue; // If object does not exist or if "NaN" is present, then just continue to the next workbook. When LabVIEW measurements are interrupted, they yield NaN values.
			else
			{
				
				string previousworkbook$=%H; // Get the name of the current window and store it in previousworkbook$
				
				if (meastype$ == "T") // if this is an transfer curve then
				{
					
					// Extract Vdlin and Vdsat
					Vdlin$=col(D)[L]$;
					Vdlin$=Vdlin.GetToken(2,"=")$; // Take the string on the right of the "=" sign
					Vdlin$=Vdlin.GetToken(1,"V")$; // Take the string on the left of the "V" (units)
					if (Vdlin.Find('.')!=0 && Vdlin.GetToken(2,".")$ == "0")
						Vdlin$=Vdlin.GetToken(1,".")$; // Take the string on the left of the "." (this line gets rid of the decimal points if the right digit is 0)
					
					
					Vdsat$=col(E)[L]$;
					Vdsat$=Vdsat.GetToken(2,"=")$; // Take the string on the right of the "=" sign
					Vdsat$=Vdsat.GetToken(1,"V")$; // Take the string on the left of the "V" (units)
					if (Vdsat.Find('.')!=0 && Vdsat.GetToken(2,".")$ == "0")
						Vdsat$=Vdsat.GetToken(1,".")$; // Take the string on the left of the "." (this line gets rid of the decimal points if the right digit is 0)
					
					
					// Extract VgStart and VgStop
					string VgStart$=$(col(A)[1]); // VgStart is the value of the first cell of col(A)
					string VgStop$=$(col(A)[wks.maxrows/2]); // VgStop is the middle cell of col(A) (assuming the gate voltage has a forward and reverse sweep) - wks.maxrows is the total number of (non-empty) rows
						
						
					// Reliability factors, current density and power density
					rlin=col(Z)[1];
					rsat=col(AA)[1];
					jmaxlin=col(AB)[1];
					jmaxsat=col(AC)[1];
					Pmaxlin=col(AD)[1];
					Pmaxsat=col(AE)[1];
					
					// Mobility correction (Riccardo di Pietro's model, DOI: 10.1063/1.4876057)
					int lastrowsat=wks.maxrows/2; // The upper limit of the integration will be equal to the half of the total number of rows. The total number of rows does not include the empty rows (use "maxrows" command instead of "nRows").	
					int firstrowsatPL=lastrowsat-round(lastrowsat/3); // The lower limit of the integration will extend at a certain number of points from the last row.
					nlbegin iy:=col(S)[firstrowsatPL:lastrowsat] func:=Power1 nltree:=ParamTree weight:=0;
					ParamTree.xc = 0;     // Assign the peak center an X-value of 0.
					ParamTree.f_xc = 1;   // Fix the peak center (f_xc = 0 is unfixed).
					nlfit;
					
					col(AP)[L]$ = "Power law fit (Saturation mobility)"; // Long name
					col(AP)[U]$ = cm^2/V*s; // Units
					col(AP) = fit(col(A), col(S));
					//range yy = col(AP)[firstrowsatPL:lastrowsat];
					//yy = fit(col(A)[firstrowsatPL:lastrowsat], col(S)[firstrowsatPL:lastrowsat]);
					beta = ParamTree.P; // The exponent beta, for the power law dependence of the mobility.
					kappa = (beta + 2)/(2*(beta+1)); // The correction factor, kappa.
					nlend;
					
					col(AQ)[L]$ = "Beta"; // Long name
					col(AQ)[1] = beta; // The exponent from the power law fitting.
					
					col(AR)[L]$ = "Correction factor"; // Long name
					col(AR)[1] = kappa; // The calculated correction factor.
					
					col(AS)[L]$ = "Corrected mobility (Saturation)"; // Long name
					col(AS)[U]$ = cm^2/V*s; // Units
					col(AS) = col(S)/kappa; // The corrected mobility is the original mobility, divided by the correction factor.
					
					//-----------------------------------------------------------------------------------------------------------------------------------------------------------
					// Column legends
					
					col(S)[C]$ = col(H)[C]$; // Comment field (graph legend)
					col(AP)[C]$ = col(H)[C]$ + ", Power law fit"; // Comment field (graph legend)
					col(AS)[C]$ = col(H)[C]$; // Comment field (graph legend)
					
					//-----------------------------------------------------------------------------------------------------------------------------------------------------------
					// Plot graphs
					// Set range variables
					range rusat = [%H]1!col(S);  // data range of Mobility (Saturation) column
					range rusatPL = [%H]1!col(AP);  // data range of Power law fit (Saturation mobility) column
					range rusatcor = [%H]1!col(AS);  // data range of Corrected mobility (Saturation) column
					
					
					
					// Plot corrected mobility (Saturation)
					string graphname$="%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(dayslength$)_u-sat-cor_Vd=%(Vdsat$)V";
					if(exist(%(uid2name(range2uid(["%(graphname$)"]))$))==0) // if there is no graph for this type of measurement then create a new graph
					{
						// Check if the template exists, otherwise, use a generic one
						string Template$="%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_u-sat-cor_Vd=%(Vdsat$)V_Vg=%(VgStart$)V to %(VgStop$)V_single.otpu"; // This is the template path
						if (exist(Template$)!=-1)// if the template exists
							win -t p "%(Template$)"; // create a graph window using template
						else
							win -t p "%(templatepath$)Generic_u-sat-cor.otpu"; // create a graph window using a generic template
						
						page.longname$ = graphname$; //this renames the active window (long name)
						page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
					};
					else
						win -a %(uid2name(range2uid(["%(graphname$)"]))$); // activate the graph window
						
					page.active = 1; // activate Layer 1
					layer -i201 rusatcor;  // plot in the active layer as scatter plot
					
					if (exist(Text2,16)==16) Text2.text$ = r\-(sat)=$(rsat) %; // If the label exists, update it
					if (exist(Text3,16)==16) Text3.text$ = J\-(ch,max,sat)=$(jmaxsat, .1) A/cm\+(2); // If the label exists, update it
					if (exist(Text4,16)==16) Text4.text$ = P\-(ch,max,sat)=$(Pmaxsat, .1) W/cm\+(2); // If the label exists, update it
					if (exist(Text5,16)==16) Text5.text$ = \g(b)=$(beta, .2); // If the label exists, update it
					if (exist(Text6,16)==16) Text6.text$ = \g(k)=$(kappa, .2); // If the label exists, update it
					plot -c; // refresh the graph to update the labels
					
					//layer -a;  // rescale the layer
					//layer -g; // Group the datasets in the layer to auto-color increment
					//layer -gu; // Ungroup the datasets in the layer
					legend; // Update the legend
					
					
					// Check if the measurement is the last measurement of a specific sample
						string nextmeassheetname$="%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(dayslength$)_%(meastype$)_$(%(measNo$)+1)_%(mode$)_%(intime$).txt";
						if(exist(%(uid2name(range2uid(["%(nextmeassheetname$)"]))$))!=0)
							continue; // if this is not the last measurement of its kind, then continue to the next iteration
					
					
					// Plot Power law fit (Saturation) for the last measurement of the sample
					string graphname$="%(batch$)_%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_%(sampleNo$)_%(deviceNo$)_%(length$)_%(condition$)_%(dayslength$)_u-sat-PLF_Vd=%(Vdsat$)V";
					if(exist(%(uid2name(range2uid(["%(graphname$)"]))$))==0) // if there is no graph for this type of measurement then create a new graph
					{
						// Check if the template exists, otherwise, use a generic one
						string Template$="%(templatepath$)%(architecture$)_%(material$)_%(concentration$)_%(solvent$)_%(annealing$)_%(additive$)_%(dielectric$)_%(dielectricconc$)_u-sat-PLF_Vd=%(Vdsat$)V_Vg=%(VgStart$)V to %(VgStop$)V_single.otpu"; // This is the template path
						if (exist(Template$)!=-1)// if the template exists
							win -t p "%(Template$)"; // create a graph window using template
						else
							win -t p "%(templatepath$)Generic_u-sat-PLF.otpu"; // create a graph window using a generic template
						
						page.longname$ = graphname$; //this renames the active window (long name)
						page.title = 1;  // Let the workbook title shows Long Name only (1 = Long Name, 2 = short name, 3 = both)
					};
					else
						win -a %(uid2name(range2uid(["%(graphname$)"]))$); // activate the graph window
						
					page.active = 1; // activate Layer 1
					layer -i201 rusat;  // plot in the active layer as scatter plot
					layer.include(rusatPL);  // plot in the active layer
					layer -i201 rusatcor;  // plot in the active layer as scatter plot
					
					if (exist(Text2,16)==16) Text2.text$ = r\-(sat)=$(rsat) %; // If the label exists, update it
					if (exist(Text3,16)==16) Text3.text$ = J\-(ch,max,sat)=$(jmaxsat, .1) A/cm\+(2); // If the label exists, update it
					if (exist(Text4,16)==16) Text4.text$ = P\-(ch,max,sat)=$(Pmaxsat, .1) W/cm\+(2); // If the label exists, update it
					if (exist(Text5,16)==16) Text5.text$ = \g(b)=$(beta, .2); // If the label exists, update it
					if (exist(Text6,16)==16) Text6.text$ = \g(k)=$(kappa, .2); // If the label exists, update it
					plot -c; // refresh the graph to update the labels
					
					//layer -a;  // rescale the layer
					//layer -g; // Group the datasets in the layer to auto-color increment
					//layer -gu; // Ungroup the datasets in the layer
					legend; // Update the legend
						
						
				};
				
				//-----------------------------------------------------------------------------------------------------------------------------------------------------------
				else // if this is an output curve
					continue;
			};
}